{
  "language": "Solidity",
  "sources": {
    "contracts/ConfigurableRightsPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n// Needed to handle structures externally\r\npragma experimental ABIEncoderV2;\r\n\r\n// Imports\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"./IBFactory.sol\";\r\nimport \"./PCToken.sol\";\r\nimport \"./utils/BalancerReentrancyGuard.sol\";\r\nimport \"./utils/BalancerOwnable.sol\";\r\nimport \"./IFCXAccessControl.sol\";\r\n\r\n// Interfaces\r\n\r\n// Libraries\r\nimport {RightsManager} from \"../libraries/RightsManager.sol\";\r\nimport \"../libraries/SmartPoolManager.sol\";\r\nimport \"../libraries/SafeApprove.sol\";\r\n\r\n// Contracts\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Smart Pool with customizable features\r\n * @notice PCToken is the \"Balancer Smart Pool\" token (transferred upon finalization)\r\n * @dev Rights are defined as follows (index values into the array)\r\n *      0: canPauseSwapping - can setPublicSwap back to false after turning it on\r\n *                            by default, it is off on initialization and can only be turned on\r\n *      1: canChangeSwapFee - can setSwapFee after initialization (by default, it is fixed at create time)\r\n *      2: canChangeWeights - can bind new token weights (allowed by default in base pool)\r\n *      3: canAddRemoveTokens - can bind/unbind tokens (allowed by default in base pool)\r\n *      4: canWhitelistLPs - can restrict LPs to a whitelist\r\n *      5: canChangeCap - can change the BSP cap (max # of pool tokens)\r\n *\r\n * Note that functions called on bPool and bFactory may look like internal calls,\r\n *   but since they are contracts accessed through an interface, they are really external.\r\n * To make this explicit, we could write \"IBPool(address(bPool)).function()\" everywhere,\r\n *   instead of \"bPool.function()\".\r\n */\r\ncontract ConfigurableRightsPool is PCToken, BalancerOwnable, BalancerReentrancyGuard {\r\n    using BalancerSafeMath for uint256;\r\n    using SafeApprove for IERC20;\r\n\r\n    // Type declarations\r\n\r\n    struct PoolParams {\r\n        // Balancer Pool Token (representing shares of the pool)\r\n        string poolTokenSymbol;\r\n        string poolTokenName;\r\n        // Tokens inside the Pool\r\n        address[] constituentTokens;\r\n        uint256[] tokenBalances;\r\n        uint256[] tokenWeights;\r\n        uint256 swapFee;\r\n        uint256 protocolFee;\r\n    }\r\n\r\n    // State variables\r\n\r\n    IBFactory public bFactory;\r\n    IBPool public bPool;\r\n\r\n    // Struct holding the rights configuration\r\n    RightsManager.Rights public rights;\r\n\r\n    // Hold the parameters used in updateWeightsGradually\r\n    SmartPoolManager.GradualUpdateParams public gradualUpdate;\r\n\r\n    // This is for adding a new (currently unbound) token to the pool\r\n    // It's a two-step process: commitAddToken(), then applyAddToken()\r\n    SmartPoolManager.NewTokenParams public newToken;\r\n\r\n    // Fee is initialized on creation, and can be changed if permission is set\r\n    // Only needed for temporary storage between construction and createPool\r\n    // Thereafter, the swap fee should always be read from the underlying pool\r\n    uint256 private _initialSwapFee;\r\n\r\n    uint256 private _initialProtocolFee;\r\n\r\n    address private _initialAccessAddress;\r\n\r\n    // Store the list of tokens in the pool, and balances\r\n    // NOTE that the token list is *only* used to store the pool tokens between\r\n    //   construction and createPool - thereafter, use the underlying BPool's list\r\n    //   (avoids synchronization issues)\r\n    address[] private _initialTokens;\r\n    uint256[] private _initialBalances;\r\n\r\n    // Enforce a minimum time between the start and end blocks\r\n    uint256 public minimumWeightChangeBlockPeriod;\r\n    // Enforce a mandatory wait time between updates\r\n    // This is also the wait time between committing and applying a new token\r\n    uint256 public addTokenTimeLockInBlocks;\r\n\r\n    // Whitelist of LPs (if configured)\r\n    mapping(address => bool) private _liquidityProviderWhitelist;\r\n\r\n    // Cap on the pool size (i.e., # of tokens minted when joining)\r\n    // Limits the risk of experimental pools; failsafe/backup for fixed-size pools\r\n    uint256 public bspCap;\r\n\r\n    // Event declarations\r\n\r\n    // Anonymous logger event - can only be filtered by contract address\r\n\r\n    event LogCall(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\r\n\r\n    event LogJoin(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\r\n\r\n    event LogExit(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\r\n\r\n    event CapChanged(address indexed caller, uint256 oldCap, uint256 newCap);\r\n\r\n    event NewTokenCommitted(address indexed token, address indexed pool, address indexed caller);\r\n\r\n    // Modifiers\r\n\r\n    modifier onlyWhitelist() {\r\n        require(\r\n            IFCXAccessControl(_initialAccessAddress).whitelisted(tx.origin),\r\n            \"FCXAccessControl: sender is not in whitelist\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier logs() {\r\n        emit LogCall(msg.sig, msg.sender, msg.data);\r\n        _;\r\n    }\r\n\r\n    // Mark functions that require delegation to the underlying Pool\r\n    modifier needsBPool() {\r\n        require(address(bPool) != address(0), \"ERR_NOT_CREATED\");\r\n        _;\r\n    }\r\n\r\n    modifier lockUnderlyingPool() {\r\n        // Turn off swapping on the underlying pool during joins\r\n        // Otherwise tokens with callbacks would enable attacks involving simultaneous swaps and joins\r\n        bool origSwapState = bPool.isPublicSwap();\r\n        bPool.setPublicSwap(false);\r\n        _;\r\n        bPool.setPublicSwap(origSwapState);\r\n    }\r\n\r\n    // Default values for these variables (used only in updateWeightsGradually), set in the constructor\r\n    // Pools without permission to update weights cannot use them anyway, and should call\r\n    //   the default createPool() function.\r\n    // To override these defaults, pass them into the overloaded createPool()\r\n    // Period is in blocks; 500 blocks ~ 2 hours; 90,000 blocks ~ 2 weeks\r\n    uint256 public constant DEFAULT_MIN_WEIGHT_CHANGE_BLOCK_PERIOD = 90000;\r\n    uint256 public constant DEFAULT_ADD_TOKEN_TIME_LOCK_IN_BLOCKS = 500;\r\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    // Function declarations\r\n\r\n    /**\r\n     * @notice Construct a new Configurable Rights Pool (wrapper around BPool)\r\n     * @dev _initialTokens and _swapFee are only used for temporary storage between construction\r\n     *      and create pool, and should not be used thereafter! _initialTokens is destroyed in\r\n     *      createPool to prevent this, and _swapFee is kept in sync (defensively), but\r\n     *      should never be used except in this constructor and createPool()\r\n     * @param factoryAddress - the BPoolFactory used to create the underlying pool\r\n     * @param poolParams - struct containing pool parameters\r\n     * @param rightsStruct - Set of permissions we are assigning to this smart pool\r\n     */\r\n    constructor(\r\n        address factoryAddress,\r\n        address logic,\r\n        PoolParams memory poolParams,\r\n        RightsManager.Rights memory rightsStruct\r\n    ) public PCToken(poolParams.poolTokenSymbol, poolParams.poolTokenName) {\r\n        // We don't have a pool yet; check now or it will fail later (in order of likelihood to fail)\r\n        // (and be unrecoverable if they don't have permission set to change it)\r\n        // Most likely to fail, so check first\r\n        require(poolParams.swapFee >= BalancerConstants.MIN_FEE, \"ERR_INVALID_SWAP_FEE\");\r\n        require(poolParams.swapFee <= BalancerConstants.MAX_FEE, \"ERR_INVALID_SWAP_FEE\");\r\n\r\n        require(poolParams.protocolFee <= BalancerConstants.MAX_FEE, \"ERR_INVALID_PROTOCOL_FEE\");\r\n        // Arrays must be parallel\r\n        require(poolParams.tokenBalances.length == poolParams.constituentTokens.length, \"ERR_START_BALANCES_MISMATCH\");\r\n        require(poolParams.tokenWeights.length == poolParams.constituentTokens.length, \"ERR_START_WEIGHTS_MISMATCH\");\r\n        // Cannot have too many or too few - technically redundant, since BPool.bind() would fail later\r\n        // But if we don't check now, we could have a useless contract with no way to create a pool\r\n\r\n        require(poolParams.constituentTokens.length >= BalancerConstants.MIN_ASSET_LIMIT, \"ERR_TOO_FEW_TOKENS\");\r\n        require(poolParams.constituentTokens.length <= BalancerConstants.MAX_ASSET_LIMIT, \"ERR_TOO_MANY_TOKENS\");\r\n        // There are further possible checks (e.g., if they use the same token twice), but\r\n        // we can let bind() catch things like that (i.e., not things that might reasonably work)\r\n\r\n        SmartPoolManager.verifyTokenCompliance(poolParams.constituentTokens);\r\n\r\n        bFactory = IBFactory(factoryAddress);\r\n        rights = rightsStruct;\r\n        _initialTokens = poolParams.constituentTokens;\r\n        _initialBalances = poolParams.tokenBalances;\r\n        _initialSwapFee = poolParams.swapFee;\r\n        _initialProtocolFee = poolParams.protocolFee;\r\n        _initialAccessAddress = bFactory.getAccessControlAddress();\r\n\r\n        // These default block time parameters can be overridden in createPool\r\n        minimumWeightChangeBlockPeriod = DEFAULT_MIN_WEIGHT_CHANGE_BLOCK_PERIOD;\r\n        addTokenTimeLockInBlocks = DEFAULT_ADD_TOKEN_TIME_LOCK_IN_BLOCKS;\r\n\r\n        gradualUpdate.startWeights = poolParams.tokenWeights;\r\n        // Initializing (unnecessarily) for documentation - 0 means no gradual weight change has been initiated\r\n        gradualUpdate.startBlock = 0;\r\n        // By default, there is no cap (unlimited pool token minting)\r\n        bspCap = BalancerConstants.MAX_UINT;\r\n\r\n        // extension\r\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\r\n        _setImplementation(logic);\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 implementation slot.\r\n     */\r\n    function _setImplementation(address newImplementation) private {\r\n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\r\n\r\n        bytes32 slot = _IMPLEMENTATION_SLOT;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            sstore(slot, newImplementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation address.\r\n     */\r\n    function _implementation() internal view returns (address impl) {\r\n        bytes32 slot = _IMPLEMENTATION_SLOT;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates the current call to `implementation`.\r\n     *\r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _delegate(address implementation) internal {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n     * function in the contract matches the call data.\r\n     */\r\n    fallback() external {\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n     * @notice Set the cap (max # of pool tokens)\r\n     * @dev _bspCap defaults in the constructor to unlimited\r\n     *      Can set to 0 (or anywhere below the current supply), to halt new investment\r\n     *      Prevent setting it before creating a pool, since createPool sets to intialSupply\r\n     *      (it does this to avoid an unlimited cap window between construction and createPool)\r\n     *      Therefore setting it before then has no effect, so should not be allowed\r\n     * @param newCap - new value of the cap\r\n     */\r\n    function setCap(uint256 newCap) external logs lock needsBPool onlyOwner {\r\n        require(rights.canChangeCap, \"ERR_CANNOT_CHANGE_CAP\");\r\n\r\n        emit CapChanged(msg.sender, bspCap, newCap);\r\n\r\n        bspCap = newCap;\r\n    }\r\n\r\n    /**\r\n     * @notice Create a new Smart Pool - and set the block period time parameters\r\n     * @dev Initialize the swap fee to the value provided in the CRP constructor\r\n     *      Can be changed if the canChangeSwapFee permission is enabled\r\n     *      Time parameters will be fixed at these values\r\n     *\r\n     *      If this contract doesn't have canChangeWeights permission - or you want to use the default\r\n     *      values, the block time arguments are not needed, and you can just call the single-argument\r\n     *      createPool()\r\n     * @param initialSupply - Starting token balance\r\n     * @param minimumWeightChangeBlockPeriodParam - Enforce a minimum time between the start and end blocks\r\n     * @param addTokenTimeLockInBlocksParam - Enforce a mandatory wait time between updates\r\n     *                                   This is also the wait time between committing and applying a new token\r\n     */\r\n    function createPool(\r\n        uint256 initialSupply,\r\n        uint256 minimumWeightChangeBlockPeriodParam,\r\n        uint256 addTokenTimeLockInBlocksParam\r\n    ) external virtual onlyOwner logs lock {\r\n        require(\r\n            minimumWeightChangeBlockPeriodParam >= addTokenTimeLockInBlocksParam,\r\n            \"ERR_INCONSISTENT_TOKEN_TIME_LOCK\"\r\n        );\r\n\r\n        minimumWeightChangeBlockPeriod = minimumWeightChangeBlockPeriodParam;\r\n        addTokenTimeLockInBlocks = addTokenTimeLockInBlocksParam;\r\n\r\n        createPoolInternal(initialSupply);\r\n    }\r\n\r\n    /**\r\n     * @notice Create a new Smart Pool\r\n     * @dev Delegates to internal function\r\n     * @param initialSupply starting token balance\r\n     */\r\n    function createPool(uint256 initialSupply) external virtual onlyOwner logs lock {\r\n        createPoolInternal(initialSupply);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the weight of an existing token\r\n     * @dev Notice Balance is not an input (like with rebind on BPool) since we will require prices not to change\r\n     *      This is achieved by forcing balances to change proportionally to weights, so that prices don't change\r\n     *      If prices could be changed, this would allow the controller to drain the pool by arbing price changes\r\n     * @param token - token to be reweighted\r\n     * @param newWeight - new weight of the token\r\n     */\r\n    function updateWeight(address token, uint256 newWeight) external virtual logs lock onlyOwner needsBPool {\r\n        require(rights.canChangeWeights, \"ERR_NOT_CONFIGURABLE_WEIGHTS\");\r\n\r\n        // We don't want people to set weights manually if there's a block-based update in progress\r\n        require(gradualUpdate.startBlock == 0, \"ERR_NO_UPDATE_DURING_GRADUAL\");\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.updateWeight(IConfigurableRightsPool(address(this)), bPool, token, newWeight);\r\n    }\r\n\r\n    /**\r\n     * @notice Update weights in a predetermined way, between startBlock and endBlock,\r\n     *         through external calls to pokeWeights\r\n     * @dev Must call pokeWeights at least once past the end for it to do the final update\r\n     *      and enable calling this again.\r\n     *      It is possible to call updateWeightsGradually during an update in some use cases\r\n     *      For instance, setting newWeights to currentWeights to stop the update where it is\r\n     * @param newWeights - final weights we want to get to. Note that the ORDER (and number) of\r\n     *                     tokens can change if you have added or removed tokens from the pool\r\n     *                     It ensures the counts are correct, but can't help you with the order!\r\n     *                     You can get the underlying BPool (it's public), and call\r\n     *                     getCurrentTokens() to see the current ordering, if you're not sure\r\n     * @param startBlock - when weights should start to change\r\n     * @param endBlock - when weights will be at their final values\r\n     */\r\n    function updateWeightsGradually(\r\n        uint256[] calldata newWeights,\r\n        uint256 startBlock,\r\n        uint256 endBlock\r\n    ) external virtual logs lock onlyOwner needsBPool {\r\n        require(rights.canChangeWeights, \"ERR_NOT_CONFIGURABLE_WEIGHTS\");\r\n        // Don't start this when we're in the middle of adding a new token\r\n        require(!newToken.isCommitted, \"ERR_PENDING_TOKEN_ADD\");\r\n\r\n        // Library computes the startBlock, computes startWeights as the current\r\n        // denormalized weights of the core pool tokens.\r\n        SmartPoolManager.updateWeightsGradually(\r\n            bPool,\r\n            gradualUpdate,\r\n            newWeights,\r\n            startBlock,\r\n            endBlock,\r\n            minimumWeightChangeBlockPeriod\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice External function called to make the contract update weights according to plan\r\n     * @dev Still works if we poke after the end of the period; also works if the weights don't change\r\n     *      Resets if we are poking beyond the end, so that we can do it again\r\n     */\r\n    function pokeWeights() external virtual logs lock needsBPool {\r\n        require(rights.canChangeWeights, \"ERR_NOT_CONFIGURABLE_WEIGHTS\");\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.pokeWeights(bPool, gradualUpdate);\r\n    }\r\n\r\n    /**\r\n     * @notice Schedule (commit) a token to be added; must call applyAddToken after a fixed\r\n     *         number of blocks to actually add the token\r\n     *\r\n     * @dev The purpose of this two-stage commit is to give warning of a potentially dangerous\r\n     *      operation. A malicious pool operator could add a large amount of a low-value token,\r\n     *      then drain the pool through price manipulation. Of course, there are many\r\n     *      legitimate purposes, such as adding additional collateral tokens.\r\n     *\r\n     * @param token - the token to be added\r\n     * @param balance - how much to be added\r\n     * @param denormalizedWeight - the desired token weight\r\n     */\r\n    function commitAddToken(\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denormalizedWeight\r\n    ) external virtual logs lock onlyOwner needsBPool {\r\n        require(rights.canAddRemoveTokens, \"ERR_CANNOT_ADD_REMOVE_TOKENS\");\r\n\r\n        // Can't do this while a progressive update is happening\r\n        require(gradualUpdate.startBlock == 0, \"ERR_NO_UPDATE_DURING_GRADUAL\");\r\n\r\n        SmartPoolManager.verifyTokenCompliance(token);\r\n\r\n        emit NewTokenCommitted(token, address(this), msg.sender);\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.commitAddToken(bPool, token, balance, denormalizedWeight, newToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Add the token previously committed (in commitAddToken) to the pool\r\n     */\r\n    function applyAddToken() external virtual logs lock onlyOwner needsBPool {\r\n        require(rights.canAddRemoveTokens, \"ERR_CANNOT_ADD_REMOVE_TOKENS\");\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.applyAddToken(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            addTokenTimeLockInBlocks,\r\n            newToken\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a token from the pool\r\n     * @dev bPool is a contract interface; function calls on it are external\r\n     * @param token - token to remove\r\n     */\r\n    function removeToken(address token) external logs lock onlyOwner needsBPool {\r\n        // It's possible to have remove rights without having add rights\r\n        require(rights.canAddRemoveTokens, \"ERR_CANNOT_ADD_REMOVE_TOKENS\");\r\n        // After createPool, token list is maintained in the underlying BPool\r\n        require(!newToken.isCommitted, \"ERR_REMOVE_WITH_ADD_PENDING\");\r\n        // Prevent removing during an update (or token lists can get out of sync)\r\n        require(gradualUpdate.startBlock == 0, \"ERR_NO_UPDATE_DURING_GRADUAL\");\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.removeToken(IConfigurableRightsPool(address(this)), bPool, token);\r\n    }\r\n\r\n    /**\r\n     * @notice Join a pool\r\n     * @dev Emits a LogJoin event (for each token)\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @param poolAmountOut - number of pool tokens to receive\r\n     * @param maxAmountsIn - Max amount of asset tokens to spend\r\n     */\r\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\r\n        external\r\n        onlyWhitelist\r\n        logs\r\n        lock\r\n        needsBPool\r\n        lockUnderlyingPool\r\n    {\r\n        require(!rights.canWhitelistLPs || _liquidityProviderWhitelist[msg.sender], \"ERR_NOT_ON_WHITELIST\");\r\n\r\n        // Delegate to library to save space\r\n\r\n        // Library computes actualAmountsIn, and does many validations\r\n        // Cannot call the push/pull/min from an external library for\r\n        // any of these pool functions. Since msg.sender can be anybody,\r\n        // they must be internal\r\n        uint256[] memory actualAmountsIn = SmartPoolManager.joinPool(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            poolAmountOut,\r\n            maxAmountsIn\r\n        );\r\n\r\n        // After createPool, token list is maintained in the underlying BPool\r\n        address[] memory poolTokens = bPool.getCurrentTokens();\r\n\r\n        for (uint256 i = 0; i < poolTokens.length; i++) {\r\n            address t = poolTokens[i];\r\n            uint256 tokenAmountIn = actualAmountsIn[i];\r\n\r\n            emit LogJoin(msg.sender, t, tokenAmountIn);\r\n\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\r\n        }\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem pool tokens for underlying assets\r\n     * @dev Emits a LogExit event for each token\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @param poolAmountIn - amount of pool tokens to redeem\r\n     * @param minAmountsOut - minimum amount of asset tokens to receive\r\n     */\r\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\r\n        external\r\n        onlyWhitelist\r\n        logs\r\n        lock\r\n        needsBPool\r\n        lockUnderlyingPool\r\n    {\r\n        // Delegate to library to save space\r\n\r\n        // Library computes actualAmountsOut, and does many validations\r\n        // Also computes the exitFee and pAiAfterExitFee\r\n        (uint256 exitFee, uint256 pAiAfterExitFee, uint256[] memory actualAmountsOut) = SmartPoolManager.exitPool(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            poolAmountIn,\r\n            minAmountsOut\r\n        );\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _pushPoolShare(address(bFactory), exitFee);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n\r\n        // After createPool, token list is maintained in the underlying BPool\r\n        address[] memory poolTokens = bPool.getCurrentTokens();\r\n\r\n        for (uint256 i = 0; i < poolTokens.length; i++) {\r\n            address t = poolTokens[i];\r\n            uint256 tokenAmountOut = actualAmountsOut[i];\r\n\r\n            emit LogExit(msg.sender, t, tokenAmountOut);\r\n\r\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Join by swapping a fixed amount of an external token in (must be present in the pool)\r\n     *         System calculates the pool token amount\r\n     * @dev emits a LogJoin event\r\n     * @param tokenIn - which token we're transferring in\r\n     * @param tokenAmountIn - amount of deposit\r\n     * @param minPoolAmountOut - minimum of pool tokens to receive\r\n     * @return poolAmountOut - amount of pool tokens minted and transferred\r\n     */\r\n    function joinswapExternAmountIn(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        uint256 minPoolAmountOut\r\n    ) external onlyWhitelist logs lock needsBPool returns (uint256 poolAmountOut) {\r\n        require(!rights.canWhitelistLPs || _liquidityProviderWhitelist[msg.sender], \"ERR_NOT_ON_WHITELIST\");\r\n\r\n        // Delegate to library to save space\r\n        poolAmountOut = SmartPoolManager.joinswapExternAmountIn(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            tokenIn,\r\n            tokenAmountIn,\r\n            minPoolAmountOut\r\n        );\r\n\r\n        emit LogJoin(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        return poolAmountOut;\r\n    }\r\n\r\n    /**\r\n     * @notice Join by swapping an external token in (must be present in the pool)\r\n     *         To receive an exact amount of pool tokens out. System calculates the deposit amount\r\n     * @dev emits a LogJoin event\r\n     * @param tokenIn - which token we're transferring in (system calculates amount required)\r\n     * @param poolAmountOut - amount of pool tokens to be received\r\n     * @param maxAmountIn - Maximum asset tokens that can be pulled to pay for the pool tokens\r\n     * @return tokenAmountIn - amount of asset tokens transferred in to purchase the pool tokens\r\n     */\r\n    function joinswapPoolAmountOut(\r\n        address tokenIn,\r\n        uint256 poolAmountOut,\r\n        uint256 maxAmountIn\r\n    ) external onlyWhitelist logs lock needsBPool returns (uint256 tokenAmountIn) {\r\n        require(!rights.canWhitelistLPs || _liquidityProviderWhitelist[msg.sender], \"ERR_NOT_ON_WHITELIST\");\r\n\r\n        // Delegate to library to save space\r\n        tokenAmountIn = SmartPoolManager.joinswapPoolAmountOut(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            tokenIn,\r\n            poolAmountOut,\r\n            maxAmountIn\r\n        );\r\n\r\n        emit LogJoin(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem a specific number of pool tokens for an underlying asset\r\n     *         Asset must be present in the pool, and will incur an EXIT_FEE (if set to non-zero)\r\n     * @dev Emits a LogExit event for the token\r\n     * @param tokenOut - which token the caller wants to receive\r\n     * @param poolAmountIn - amount of pool tokens to redeem\r\n     * @param minAmountOut - minimum asset tokens to receive\r\n     * @return tokenAmountOut - amount of asset tokens returned\r\n     */\r\n    function exitswapPoolAmountIn(\r\n        address tokenOut,\r\n        uint256 poolAmountIn,\r\n        uint256 minAmountOut\r\n    ) external onlyWhitelist logs lock needsBPool returns (uint256 tokenAmountOut) {\r\n        // Delegate to library to save space\r\n\r\n        // Calculates final amountOut, and the fee and final amount in\r\n        (uint256 exitFee, uint256 amountOut) = SmartPoolManager.exitswapPoolAmountIn(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            tokenOut,\r\n            poolAmountIn,\r\n            minAmountOut\r\n        );\r\n\r\n        tokenAmountOut = amountOut;\r\n        uint256 pAiAfterExitFee = BalancerSafeMath.bsub(poolAmountIn, exitFee);\r\n\r\n        emit LogExit(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n        _pushPoolShare(address(bFactory), exitFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem pool tokens for a specific amount of underlying assets\r\n     *         Asset must be present in the pool\r\n     * @dev Emits a LogExit event for the token\r\n     * @param tokenOut - which token the caller wants to receive\r\n     * @param tokenAmountOut - amount of underlying asset tokens to receive\r\n     * @param maxPoolAmountIn - maximum pool tokens to be redeemed\r\n     * @return poolAmountIn - amount of pool tokens redeemed\r\n     */\r\n    function exitswapExternAmountOut(\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPoolAmountIn\r\n    ) external onlyWhitelist logs lock needsBPool returns (uint256 poolAmountIn) {\r\n        // Delegate to library to save space\r\n\r\n        // Calculates final amounts in, accounting for the exit fee\r\n        (uint256 exitFee, uint256 amountIn) = SmartPoolManager.exitswapExternAmountOut(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            tokenOut,\r\n            tokenAmountOut,\r\n            maxPoolAmountIn\r\n        );\r\n\r\n        poolAmountIn = amountIn;\r\n        uint256 pAiAfterExitFee = BalancerSafeMath.bsub(poolAmountIn, exitFee);\r\n\r\n        emit LogExit(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n        _pushPoolShare(address(bFactory), exitFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return poolAmountIn;\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for specific permissions\r\n     * @dev value of the enum is just the 0-based index in the enumeration\r\n     *      For instance canPauseSwapping is 0; canChangeWeights is 2\r\n     * @return token boolean true if we have the given permission\r\n     */\r\n    function hasPermission(RightsManager.Permissions permission) external view virtual returns (bool) {\r\n        return RightsManager.hasPermission(rights, permission);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the RightsManager contract\r\n     * @dev Convenience function to get the address of the RightsManager library (so clients can check version)\r\n     * @return address of the RightsManager library\r\n     */\r\n    function getRightsManagerVersion() external pure returns (address) {\r\n        return address(RightsManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the BalancerSafeMath contract\r\n     * @dev Convenience function to get the address of the BalancerSafeMath library (so clients can check version)\r\n     * @return address of the BalancerSafeMath library\r\n     */\r\n    function getBalancerSafeMathVersion() external pure returns (address) {\r\n        return address(BalancerSafeMath);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the SmartPoolManager contract\r\n     * @dev Convenience function to get the address of the SmartPoolManager library (so clients can check version)\r\n     * @return address of the SmartPoolManager library\r\n     */\r\n    function getSmartPoolManagerVersion() external pure returns (address) {\r\n        return address(SmartPoolManager);\r\n    }\r\n\r\n    // Public functions\r\n\r\n    // \"Public\" versions that can safely be called from SmartPoolManager\r\n    // Allows only the contract itself to call them (not the controller or any external account)\r\n\r\n    function mintPoolShareFromLib(uint256 amount) public {\r\n        require(msg.sender == address(this), \"ERR_NOT_CONTROLLER\");\r\n\r\n        _mint(amount);\r\n    }\r\n\r\n    function pushPoolShareFromLib(address to, uint256 amount) public {\r\n        require(msg.sender == address(this), \"ERR_NOT_CONTROLLER\");\r\n\r\n        _push(to, amount);\r\n    }\r\n\r\n    function pullPoolShareFromLib(address from, uint256 amount) public {\r\n        require(msg.sender == address(this), \"ERR_NOT_CONTROLLER\");\r\n\r\n        _pull(from, amount);\r\n    }\r\n\r\n    function burnPoolShareFromLib(uint256 amount) public {\r\n        require(msg.sender == address(this), \"ERR_NOT_CONTROLLER\");\r\n\r\n        _burn(amount);\r\n    }\r\n\r\n    // Internal functions\r\n\r\n    // Lint wants the function to have a leading underscore too\r\n    /* solhint-disable private-vars-leading-underscore */\r\n\r\n    /**\r\n     * @notice Create a new Smart Pool\r\n     * @dev Initialize the swap fee to the value provided in the CRP constructor\r\n     *      Can be changed if the canChangeSwapFee permission is enabled\r\n     * @param initialSupply starting token balance\r\n     */\r\n    function createPoolInternal(uint256 initialSupply) internal {\r\n        require(address(bPool) == address(0), \"ERR_IS_CREATED\");\r\n        require(initialSupply >= BalancerConstants.MIN_POOL_SUPPLY, \"ERR_INIT_SUPPLY_MIN\");\r\n        require(initialSupply <= BalancerConstants.MAX_POOL_SUPPLY, \"ERR_INIT_SUPPLY_MAX\");\r\n\r\n        // If the controller can change the cap, initialize it to the initial supply\r\n        // Defensive programming, so that there is no gap between creating the pool\r\n        // (initialized to unlimited in the constructor), and setting the cap,\r\n        // which they will presumably do if they have this right.\r\n        if (rights.canChangeCap) {\r\n            bspCap = initialSupply;\r\n        }\r\n\r\n        // There is technically reentrancy here, since we're making external calls and\r\n        // then transferring tokens. However, the external calls are all to the underlying BPool\r\n\r\n        // To the extent possible, modify state variables before calling functions\r\n        _mintPoolShare(initialSupply);\r\n        _pushPoolShare(msg.sender, initialSupply);\r\n\r\n        // Deploy new BPool (bFactory and bPool are interfaces; all calls are external)\r\n        bPool = bFactory.newBPool();\r\n\r\n        // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\r\n        require(bPool.EXIT_FEE() == 0, \"ERR_NONZERO_EXIT_FEE\");\r\n        require(BalancerConstants.EXIT_FEE == 0, \"ERR_NONZERO_EXIT_FEE\");\r\n\r\n        for (uint256 i = 0; i < _initialTokens.length; i++) {\r\n            address t = _initialTokens[i];\r\n            uint256 bal = _initialBalances[i];\r\n            uint256 denorm = gradualUpdate.startWeights[i];\r\n\r\n            bool returnValue = IERC20(t).transferFrom(msg.sender, address(this), bal);\r\n            require(returnValue, \"ERR_ERC20_FALSE\");\r\n\r\n            returnValue = IERC20(t).safeApprove(address(bPool), BalancerConstants.MAX_UINT);\r\n            require(returnValue, \"ERR_ERC20_FALSE\");\r\n\r\n            bPool.bind(t, bal, denorm);\r\n        }\r\n\r\n        while (_initialTokens.length > 0) {\r\n            // Modifying state variable after external calls here,\r\n            // but not essential, so not dangerous\r\n            _initialTokens.pop();\r\n        }\r\n\r\n        // Set fee to the initial value set in the constructor\r\n        // Hereafter, read the swapFee from the underlying pool, not the local state variable\r\n        bPool.setSwapFee(_initialSwapFee);\r\n        bPool.setPublicSwap(true);\r\n        bPool.setProtocolFee(_initialProtocolFee);\r\n        bPool.setAccessControlAddress(_initialAccessAddress);\r\n\r\n        // \"destroy\" the temporary swap fee (like _initialTokens above) in case a subclass tries to use it\r\n        _initialSwapFee = 0;\r\n        _initialProtocolFee = 0;\r\n    }\r\n\r\n    /* solhint-enable private-vars-leading-underscore */\r\n\r\n    // Rebind BPool and pull tokens from address\r\n    // bPool is a contract interface; function calls on it are external\r\n    function _pullUnderlying(\r\n        address erc20,\r\n        address from,\r\n        uint256 amount\r\n    ) internal needsBPool {\r\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\r\n        uint256 tokenBalance = bPool.getBalance(erc20);\r\n        uint256 tokenWeight = bPool.getDenormalizedWeight(erc20);\r\n\r\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n        bPool.rebind(erc20, BalancerSafeMath.badd(tokenBalance, amount), tokenWeight);\r\n    }\r\n\r\n    // Rebind BPool and push tokens to address\r\n    // bPool is a contract interface; function calls on it are external\r\n    function _pushUnderlying(\r\n        address erc20,\r\n        address to,\r\n        uint256 amount\r\n    ) internal needsBPool {\r\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\r\n        uint256 tokenBalance = bPool.getBalance(erc20);\r\n        uint256 tokenWeight = bPool.getDenormalizedWeight(erc20);\r\n        bPool.rebind(erc20, BalancerSafeMath.bsub(tokenBalance, amount), tokenWeight);\r\n\r\n        bool xfer = IERC20(erc20).transfer(to, amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n    }\r\n\r\n    // Wrappers around corresponding core functions\r\n\r\n    //\r\n    function _mint(uint256 amount) internal override {\r\n        super._mint(amount);\r\n        require(varTotalSupply <= bspCap, \"ERR_CAP_LIMIT_REACHED\");\r\n    }\r\n\r\n    function _mintPoolShare(uint256 amount) internal {\r\n        _mint(amount);\r\n    }\r\n\r\n    function _pushPoolShare(address to, uint256 amount) internal {\r\n        _push(to, amount);\r\n    }\r\n\r\n    function _pullPoolShare(address from, uint256 amount) internal {\r\n        _pull(from, amount);\r\n    }\r\n\r\n    function _burnPoolShare(uint256 amount) internal {\r\n        _burn(amount);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/IBFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\ninterface IBPool {\r\n    function rebind(\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denorm\r\n    ) external;\r\n\r\n    function setSwapFee(uint256 swapFee) external;\r\n\r\n    function setProtocolFee(uint256 protocolFee) external;\r\n\r\n    function setRoles(bytes32[] memory roles) external;\r\n\r\n    function setAccessControlAddress(address accessAddress) external;\r\n\r\n    function setPublicSwap(bool publicSwap) external;\r\n\r\n    function bind(\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denorm\r\n    ) external;\r\n\r\n    function unbind(address token) external;\r\n\r\n    function gulp(address token) external;\r\n\r\n    function isBound(address token) external view returns (bool);\r\n\r\n    function getBalance(address token) external view returns (uint256);\r\n\r\n    function getSwapFee() external view returns (uint256);\r\n\r\n    function getProtocolFee() external view returns (uint256);\r\n\r\n    function isPublicSwap() external view returns (bool);\r\n\r\n    function getDenormalizedWeight(address token) external view returns (uint256);\r\n\r\n    function getTotalDenormalizedWeight() external view returns (uint256);\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function EXIT_FEE() external view returns (uint256);\r\n\r\n    function calcPoolOutGivenSingleIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 tokenAmountIn,\r\n        uint256 swapFee\r\n    ) external pure returns (uint256 poolAmountOut);\r\n\r\n    function calcSingleInGivenPoolOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 poolAmountOut,\r\n        uint256 swapFee\r\n    ) external pure returns (uint256 tokenAmountIn);\r\n\r\n    function calcSingleOutGivenPoolIn(\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 poolAmountIn,\r\n        uint256 swapFee\r\n    ) external pure returns (uint256 tokenAmountOut);\r\n\r\n    function calcPoolInGivenSingleOut(\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 tokenAmountOut,\r\n        uint256 swapFee\r\n    ) external pure returns (uint256 poolAmountIn);\r\n\r\n    function isFinalized() external view returns (bool);\r\n\r\n    function getNumTokens() external view returns (uint256);\r\n\r\n    function getCurrentTokens() external view returns (address[] memory);\r\n\r\n    function getFinalTokens() external view returns (address[] memory);\r\n\r\n    function getNormalizedWeight(address) external view returns (uint256);\r\n\r\n    function getController() external view returns (address);\r\n\r\n    function getAccessControlAddress() external view returns (address);\r\n\r\n    function getRoles() external view returns (bytes32[] memory);\r\n\r\n    function setController(address) external;\r\n\r\n    function getSpotPrice(address, address) external view returns (uint256);\r\n\r\n    function getSpotPriceSansFee(address, address) external view returns (uint256);\r\n\r\n    function finalize() external;\r\n\r\n    // BPool function\r\n    event LOG_SWAP(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        address indexed tokenOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 tokenAmountOut\r\n    );\r\n\r\n    function joinPool(uint256, uint256[] calldata) external;\r\n\r\n    function swapExactAmountIn(\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\r\n\r\n    function swapExactAmountOut(\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\r\n\r\n    function exitPool(uint256, uint256[] calldata) external;\r\n\r\n    function joinswapExternAmountIn(\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256 poolAmountOut);\r\n\r\n    function joinswapPoolAmountOut(\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256 tokenAmountIn);\r\n\r\n    function exitswapPoolAmountIn(\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256 tokenAmountOut);\r\n\r\n    function exitswapExternAmountOut(\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256 poolAmountIn);\r\n\r\n    // ERC20\r\n    event Approval(address indexed src, address indexed dst, uint256 amt);\r\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address whom) external view returns (uint256);\r\n\r\n    function allowance(address src, address dst) external view returns (uint256);\r\n\r\n    function approve(address dst, uint256 amt) external returns (bool);\r\n\r\n    function transfer(address dst, uint256 amt) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 amt\r\n    ) external returns (bool);\r\n\r\n    function increaseApproval(address, uint256) external returns (bool);\r\n\r\n    function decreaseApproval(address, uint256) external returns (bool);\r\n}\r\n\r\ninterface IBFactory {\r\n    function newBPool() external returns (IBPool);\r\n\r\n    function setBLabs(address b) external;\r\n\r\n    function collect(IBPool pool) external;\r\n\r\n    function isBPool(address b) external view returns (bool);\r\n\r\n    function getBLabs() external view returns (address);\r\n\r\n    function getAccessControlAddress() external view returns (address);\r\n}\r\n"
    },
    "contracts/PCToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n// Imports\r\n\r\nimport \"../libraries/BalancerSafeMath.sol\";\r\nimport \"../interfaces/IERC20.sol\";\r\n\r\n// Contracts\r\n\r\n/* solhint-disable func-order */\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Highly opinionated token implementation\r\n */\r\ncontract PCToken is IERC20 {\r\n    using BalancerSafeMath for uint256;\r\n\r\n    // State variables\r\n    string public constant NAME = \"Balancer Smart Pool\";\r\n    uint8 public constant DECIMALS = 18;\r\n\r\n    // No leading underscore per naming convention (non-private)\r\n    // Cannot call totalSupply (name conflict)\r\n    // solhint-disable-next-line private-vars-leading-underscore\r\n    uint256 internal varTotalSupply;\r\n\r\n    mapping(address => uint256) private _balance;\r\n    mapping(address => mapping(address => uint256)) private _allowance;\r\n\r\n    string private _symbol;\r\n    string private _name;\r\n\r\n    // Event declarations\r\n\r\n    // See definitions above; must be redeclared to be emitted from this contract\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // Function declarations\r\n\r\n    /**\r\n     * @notice Base token constructor\r\n     * @param tokenSymbol - the token symbol\r\n     */\r\n    constructor(string memory tokenSymbol, string memory tokenName) public {\r\n        _symbol = tokenSymbol;\r\n        _name = tokenName;\r\n    }\r\n\r\n    // External functions\r\n\r\n    /**\r\n     * @notice Getter for allowance: amount spender will be allowed to spend on behalf of owner\r\n     * @param owner - owner of the tokens\r\n     * @param spender - entity allowed to spend the tokens\r\n     * @return uint - remaining amount spender is allowed to transfer\r\n     */\r\n    function allowance(address owner, address spender) external view override returns (uint256) {\r\n        return _allowance[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for current account balance\r\n     * @param account - address we're checking the balance of\r\n     * @return uint - token balance in the account\r\n     */\r\n    function balanceOf(address account) external view override returns (uint256) {\r\n        return _balance[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Approve owner (sender) to spend a certain amount\r\n     * @dev emits an Approval event\r\n     * @param spender - entity the owner (sender) is approving to spend his tokens\r\n     * @param amount - number of tokens being approved\r\n     * @return bool - result of the approval (will always be true if it doesn't revert)\r\n     */\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        /* In addition to the increase/decreaseApproval functions, could\r\n           avoid the \"approval race condition\" by only allowing calls to approve\r\n           when the current approval amount is 0\r\n        \r\n           require(_allowance[msg.sender][spender] == 0, \"ERR_RACE_CONDITION\");\r\n\r\n           Some token contracts (e.g., KNC), already revert if you call approve \r\n           on a non-zero allocation. To deal with these, we use the SafeApprove library\r\n           and safeApprove function when adding tokens to the pool.\r\n        */\r\n\r\n        _allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Increase the amount the spender is allowed to spend on behalf of the owner (sender)\r\n     * @dev emits an Approval event\r\n     * @param spender - entity the owner (sender) is approving to spend his tokens\r\n     * @param amount - number of tokens being approved\r\n     * @return bool - result of the approval (will always be true if it doesn't revert)\r\n     */\r\n    function increaseApproval(address spender, uint256 amount) external returns (bool) {\r\n        _allowance[msg.sender][spender] = BalancerSafeMath.badd(_allowance[msg.sender][spender], amount);\r\n\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Decrease the amount the spender is allowed to spend on behalf of the owner (sender)\r\n     * @dev emits an Approval event\r\n     * @dev If you try to decrease it below the current limit, it's just set to zero (not an error)\r\n     * @param spender - entity the owner (sender) is approving to spend his tokens\r\n     * @param amount - number of tokens being approved\r\n     * @return bool - result of the approval (will always be true if it doesn't revert)\r\n     */\r\n    function decreaseApproval(address spender, uint256 amount) external returns (bool) {\r\n        uint256 oldValue = _allowance[msg.sender][spender];\r\n        // Gas optimization - if amount == oldValue (or is larger), set to zero immediately\r\n        if (amount >= oldValue) {\r\n            _allowance[msg.sender][spender] = 0;\r\n        } else {\r\n            _allowance[msg.sender][spender] = BalancerSafeMath.bsub(oldValue, amount);\r\n        }\r\n\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer the given amount from sender (caller) to recipient\r\n     * @dev _move emits a Transfer event if successful\r\n     * @param recipient - entity receiving the tokens\r\n     * @param amount - number of tokens being transferred\r\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\r\n     */\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        require(recipient != address(0), \"ERR_ZERO_ADDRESS\");\r\n\r\n        _move(msg.sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer the given amount from sender to recipient\r\n     * @dev _move emits a Transfer event if successful; may also emit an Approval event\r\n     * @param sender - entity sending the tokens (must be caller or allowed to spend on behalf of caller)\r\n     * @param recipient - recipient of the tokens\r\n     * @param amount - number of tokens being transferred\r\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        require(recipient != address(0), \"ERR_ZERO_ADDRESS\");\r\n        require(msg.sender == sender || amount <= _allowance[sender][msg.sender], \"ERR_PCTOKEN_BAD_CALLER\");\r\n\r\n        _move(sender, recipient, amount);\r\n\r\n        // memoize for gas optimization\r\n        uint256 oldAllowance = _allowance[sender][msg.sender];\r\n\r\n        // If the sender is not the caller, adjust the allowance by the amount transferred\r\n        if (msg.sender != sender && oldAllowance != uint256(-1)) {\r\n            _allowance[sender][msg.sender] = BalancerSafeMath.bsub(oldAllowance, amount);\r\n\r\n            emit Approval(msg.sender, recipient, _allowance[sender][msg.sender]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // public functions\r\n\r\n    /**\r\n     * @notice Getter for the total supply\r\n     * @dev declared external for gas optimization\r\n     * @return uint - total number of tokens in existence\r\n     */\r\n    function totalSupply() external view override returns (uint256) {\r\n        return varTotalSupply;\r\n    }\r\n\r\n    // Public functions\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     *      We allow the user to set this name (as well as the symbol).\r\n     *      Alternatives are 1) A fixed string (original design)\r\n     *                       2) A fixed string plus the user-defined symbol\r\n     *                          return string(abi.encodePacked(NAME, \"-\", _symbol));\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() external pure returns (uint8) {\r\n        return DECIMALS;\r\n    }\r\n\r\n    // internal functions\r\n\r\n    // Mint an amount of new tokens, and add them to the balance (and total supply)\r\n    // Emit a transfer amount from the null address to this contract\r\n    function _mint(uint256 amount) internal virtual {\r\n        _balance[address(this)] = BalancerSafeMath.badd(_balance[address(this)], amount);\r\n        varTotalSupply = BalancerSafeMath.badd(varTotalSupply, amount);\r\n\r\n        emit Transfer(address(0), address(this), amount);\r\n    }\r\n\r\n    // Burn an amount of new tokens, and subtract them from the balance (and total supply)\r\n    // Emit a transfer amount from this contract to the null address\r\n    function _burn(uint256 amount) internal virtual {\r\n        // Can't burn more than we have\r\n        // Remove require for gas optimization - bsub will revert on underflow\r\n        // require(_balance[address(this)] >= amount, \"ERR_INSUFFICIENT_BAL\");\r\n\r\n        _balance[address(this)] = BalancerSafeMath.bsub(_balance[address(this)], amount);\r\n        varTotalSupply = BalancerSafeMath.bsub(varTotalSupply, amount);\r\n\r\n        emit Transfer(address(this), address(0), amount);\r\n    }\r\n\r\n    // Transfer tokens from sender to recipient\r\n    // Adjust balances, and emit a Transfer event\r\n    function _move(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        // Can't send more than sender has\r\n        // Remove require for gas optimization - bsub will revert on underflow\r\n        // require(_balance[sender] >= amount, \"ERR_INSUFFICIENT_BAL\");\r\n\r\n        _balance[sender] = BalancerSafeMath.bsub(_balance[sender], amount);\r\n        _balance[recipient] = BalancerSafeMath.badd(_balance[recipient], amount);\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    // Transfer from this contract to recipient\r\n    // Emits a transfer event if successful\r\n    function _push(address recipient, uint256 amount) internal {\r\n        _move(address(this), recipient, amount);\r\n    }\r\n\r\n    // Transfer from recipient to this contract\r\n    // Emits a transfer event if successful\r\n    function _pull(address sender, uint256 amount) internal {\r\n        _move(sender, address(this), amount);\r\n    }\r\n}\r\n"
    },
    "contracts/utils/BalancerReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @author Balancer Labs (and OpenZeppelin)\r\n * @title Protect against reentrant calls (and also selectively protect view functions)\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {_lock_} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `_lock_` guard, functions marked as\r\n * `_lock_` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `_lock_` entry\r\n * points to them.\r\n *\r\n * Also adds a _lockview_ modifier, which doesn't create a lock, but fails\r\n *   if another _lock_ call is in progress\r\n */\r\ncontract BalancerReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `_lock_` function from another `_lock_`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `_lock_` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier lock() {\r\n        // On the first call to _lock_, _notEntered will be true\r\n        require(_status != _ENTERED, \"ERR_REENTRY\");\r\n\r\n        // Any calls to _lock_ after this point will fail\r\n        _status = _ENTERED;\r\n        _;\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Also add a modifier that doesn't create a lock, but protects functions that\r\n     *      should not be called while a _lock_ function is running\r\n     */\r\n    modifier viewlock() {\r\n        require(_status != _ENTERED, \"ERR_REENTRY_VIEW\");\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/utils/BalancerOwnable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract BalancerOwnable {\r\n    // State variables\r\n\r\n    address private _owner;\r\n\r\n    // Event declarations\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // Modifiers\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"ERR_NOT_CONTROLLER\");\r\n        _;\r\n    }\r\n\r\n    // Function declarations\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\r\n     *         Can only be called by the current owner\r\n     * @dev external for gas optimization\r\n     * @param newOwner - address of new owner\r\n     */\r\n    function setController(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"ERR_ZERO_ADDRESS\");\r\n\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of the current owner\r\n     * @dev external for gas optimization\r\n     * @return address - of the owner (AKA controller)\r\n     */\r\n    function getController() external view returns (address) {\r\n        return _owner;\r\n    }\r\n}\r\n"
    },
    "contracts/IFCXAccessControl.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\ninterface IFCXAccessControl {\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\r\n\r\n    function whitelisted(address account) external view returns (bool);\r\n}\r\n"
    },
    "libraries/RightsManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n// Needed to handle structures externally\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Manage Configurable Rights for the smart pool\r\n *      canPauseSwapping - can setPublicSwap back to false after turning it on\r\n *                         by default, it is off on initialization and can only be turned on\r\n *      canChangeSwapFee - can setSwapFee after initialization (by default, it is fixed at create time)\r\n *      canChangeWeights - can bind new token weights (allowed by default in base pool)\r\n *      canAddRemoveTokens - can bind/unbind tokens (allowed by default in base pool)\r\n *      canWhitelistLPs - can limit liquidity providers to a given set of addresses\r\n *      canChangeCap - can change the BSP cap (max # of pool tokens)\r\n */\r\nlibrary RightsManager {\r\n\r\n    // Type declarations\r\n\r\n    enum Permissions { PAUSE_SWAPPING,\r\n                       CHANGE_SWAP_FEE,\r\n                       CHANGE_WEIGHTS,\r\n                       ADD_REMOVE_TOKENS,\r\n                       WHITELIST_LPS,\r\n                       CHANGE_CAP,\r\n                       CHANGE_PROTOCOL_FEE }\r\n\r\n    struct Rights {\r\n        bool canPauseSwapping;\r\n        bool canChangeSwapFee;\r\n        bool canChangeWeights;\r\n        bool canAddRemoveTokens;\r\n        bool canWhitelistLPs;\r\n        bool canChangeCap;\r\n        bool canChangeProtocolFee;\r\n    }\r\n\r\n    // State variables (can only be constants in a library)\r\n    bool public constant DEFAULT_CAN_PAUSE_SWAPPING = false;\r\n    bool public constant DEFAULT_CAN_CHANGE_SWAP_FEE = true;\r\n    bool public constant DEFAULT_CAN_CHANGE_WEIGHTS = true;\r\n    bool public constant DEFAULT_CAN_ADD_REMOVE_TOKENS = false;\r\n    bool public constant DEFAULT_CAN_WHITELIST_LPS = false;\r\n    bool public constant DEFAULT_CAN_CHANGE_CAP = false;\r\n    bool public constant DEFAULT_CAN_CHANGE_PROTOCOL_FEE = true;\r\n    // Functions\r\n\r\n    /**\r\n     * @notice create a struct from an array (or return defaults)\r\n     * @dev If you pass an empty array, it will construct it using the defaults\r\n     * @param a - array input\r\n     * @return Rights struct\r\n     */ \r\n    function constructRights(bool[] calldata a) external pure returns (Rights memory) {\r\n        if (a.length == 0) {\r\n            return Rights(DEFAULT_CAN_PAUSE_SWAPPING,\r\n                          DEFAULT_CAN_CHANGE_SWAP_FEE,\r\n                          DEFAULT_CAN_CHANGE_WEIGHTS,\r\n                          DEFAULT_CAN_ADD_REMOVE_TOKENS,\r\n                          DEFAULT_CAN_WHITELIST_LPS,\r\n                          DEFAULT_CAN_CHANGE_CAP,\r\n                          DEFAULT_CAN_CHANGE_PROTOCOL_FEE);\r\n        }\r\n        else {\r\n            return Rights(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Convert rights struct to an array (e.g., for events, GUI)\r\n     * @dev avoids multiple calls to hasPermission\r\n     * @param rights - the rights struct to convert\r\n     * @return boolean array containing the rights settings\r\n     */\r\n    function convertRights(Rights calldata rights) external pure returns (bool[] memory) {\r\n        bool[] memory result = new bool[](7);\r\n\r\n        result[0] = rights.canPauseSwapping;\r\n        result[1] = rights.canChangeSwapFee;\r\n        result[2] = rights.canChangeWeights;\r\n        result[3] = rights.canAddRemoveTokens;\r\n        result[4] = rights.canWhitelistLPs;\r\n        result[5] = rights.canChangeCap;\r\n        result[6] = rights.canChangeProtocolFee;\r\n\r\n        return result;\r\n    }\r\n\r\n    // Though it is actually simple, the number of branches triggers code-complexity\r\n    /* solhint-disable code-complexity */\r\n\r\n    /**\r\n     * @notice Externally check permissions using the Enum\r\n     * @param self - Rights struct containing the permissions\r\n     * @param permission - The permission to check\r\n     * @return Boolean true if it has the permission\r\n     */\r\n    function hasPermission(Rights calldata self, Permissions permission) external pure returns (bool) {\r\n        if (Permissions.PAUSE_SWAPPING == permission) {\r\n            return self.canPauseSwapping;\r\n        }\r\n        else if (Permissions.CHANGE_SWAP_FEE == permission) {\r\n            return self.canChangeSwapFee;\r\n        }\r\n        else if (Permissions.CHANGE_WEIGHTS == permission) {\r\n            return self.canChangeWeights;\r\n        }\r\n        else if (Permissions.ADD_REMOVE_TOKENS == permission) {\r\n            return self.canAddRemoveTokens;\r\n        }\r\n        else if (Permissions.WHITELIST_LPS == permission) {\r\n            return self.canWhitelistLPs;\r\n        }\r\n        else if (Permissions.CHANGE_CAP == permission) {\r\n            return self.canChangeCap;\r\n        }\r\n        else if (Permissions.CHANGE_PROTOCOL_FEE == permission) {\r\n            return self.canChangeProtocolFee;\r\n        }\r\n    }\r\n\r\n    /* solhint-enable code-complexity */\r\n}\r\n"
    },
    "libraries/SmartPoolManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n// Needed to pass in structs\r\npragma experimental ABIEncoderV2;\r\n\r\n// Imports\r\n\r\nimport \"../interfaces/IERC20.sol\";\r\nimport \"../interfaces/IConfigurableRightsPool.sol\";\r\nimport \"../contracts/IBFactory.sol\";\r\nimport \"./BalancerSafeMath.sol\";\r\nimport \"./SafeApprove.sol\";\r\n\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Factor out the weight updates\r\n */\r\nlibrary SmartPoolManager {\r\n    // Type declarations\r\n\r\n    struct NewTokenParams {\r\n        address addr;\r\n        bool isCommitted;\r\n        uint commitBlock;\r\n        uint denorm;\r\n        uint balance;\r\n    }\r\n\r\n    // For blockwise, automated weight updates\r\n    // Move weights linearly from startWeights to endWeights,\r\n    // between startBlock and endBlock\r\n    struct GradualUpdateParams {\r\n        uint startBlock;\r\n        uint endBlock;\r\n        uint[] startWeights;\r\n        uint[] endWeights;\r\n    }\r\n\r\n    // updateWeight and pokeWeights are unavoidably long\r\n    /* solhint-disable function-max-lines */\r\n\r\n    /**\r\n     * @notice Update the weight of an existing token\r\n     * @dev Refactored to library to make CRPFactory deployable\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param token - token to be reweighted\r\n     * @param newWeight - new weight of the token\r\n    */\r\n    function updateWeight(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address token,\r\n        uint newWeight\r\n    )\r\n        external\r\n    {\r\n        require(newWeight >= BalancerConstants.MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\r\n        require(newWeight <= BalancerConstants.MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\r\n\r\n        uint currentWeight = bPool.getDenormalizedWeight(token);\r\n        // Save gas; return immediately on NOOP\r\n        if (currentWeight == newWeight) {\r\n             return;\r\n        }\r\n\r\n        uint currentBalance = bPool.getBalance(token);\r\n        uint totalSupply = self.totalSupply();\r\n        uint totalWeight = bPool.getTotalDenormalizedWeight();\r\n        uint poolShares;\r\n        uint deltaBalance;\r\n        uint deltaWeight;\r\n        uint newBalance;\r\n\r\n        if (newWeight < currentWeight) {\r\n            // This means the controller will withdraw tokens to keep price\r\n            // So they need to redeem PCTokens\r\n            deltaWeight = BalancerSafeMath.bsub(currentWeight, newWeight);\r\n\r\n            // poolShares = totalSupply * (deltaWeight / totalWeight)\r\n            poolShares = BalancerSafeMath.bmul(totalSupply,\r\n                                               BalancerSafeMath.bdiv(deltaWeight, totalWeight));\r\n\r\n            // deltaBalance = currentBalance * (deltaWeight / currentWeight)\r\n            deltaBalance = BalancerSafeMath.bmul(currentBalance,\r\n                                                 BalancerSafeMath.bdiv(deltaWeight, currentWeight));\r\n\r\n            // New balance cannot be lower than MIN_BALANCE\r\n            newBalance = BalancerSafeMath.bsub(currentBalance, deltaBalance);\r\n\r\n            require(newBalance >= BalancerConstants.MIN_BALANCE, \"ERR_MIN_BALANCE\");\r\n\r\n            // First get the tokens from this contract (Pool Controller) to msg.sender\r\n            bPool.rebind(token, newBalance, newWeight);\r\n\r\n            // Now with the tokens this contract can send them to msg.sender\r\n            bool xfer = IERC20(token).transfer(msg.sender, deltaBalance);\r\n            require(xfer, \"ERR_ERC20_FALSE\");\r\n\r\n            self.pullPoolShareFromLib(msg.sender, poolShares);\r\n            self.burnPoolShareFromLib(poolShares);\r\n        }\r\n        else {\r\n            // This means the controller will deposit tokens to keep the price.\r\n            // They will be minted and given PCTokens\r\n            deltaWeight = BalancerSafeMath.bsub(newWeight, currentWeight);\r\n\r\n            require(BalancerSafeMath.badd(totalWeight, deltaWeight) <= BalancerConstants.MAX_TOTAL_WEIGHT,\r\n                    \"ERR_MAX_TOTAL_WEIGHT\");\r\n\r\n            // poolShares = totalSupply * (deltaWeight / totalWeight)\r\n            poolShares = BalancerSafeMath.bmul(totalSupply,\r\n                                               BalancerSafeMath.bdiv(deltaWeight, totalWeight));\r\n            // deltaBalance = currentBalance * (deltaWeight / currentWeight)\r\n            deltaBalance = BalancerSafeMath.bmul(currentBalance,\r\n                                                 BalancerSafeMath.bdiv(deltaWeight, currentWeight));\r\n\r\n            // First gets the tokens from msg.sender to this contract (Pool Controller)\r\n            bool xfer = IERC20(token).transferFrom(msg.sender, address(this), deltaBalance);\r\n            require(xfer, \"ERR_ERC20_FALSE\");\r\n\r\n            // Now with the tokens this contract can bind them to the pool it controls\r\n            bPool.rebind(token, BalancerSafeMath.badd(currentBalance, deltaBalance), newWeight);\r\n\r\n            self.mintPoolShareFromLib(poolShares);\r\n            self.pushPoolShareFromLib(msg.sender, poolShares);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice External function called to make the contract update weights according to plan\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param gradualUpdate - gradual update parameters from the CRP\r\n    */\r\n    function pokeWeights(\r\n        IBPool bPool,\r\n        GradualUpdateParams storage gradualUpdate\r\n    )\r\n        external\r\n    {\r\n        // Do nothing if we call this when there is no update plan\r\n        if (gradualUpdate.startBlock == 0) {\r\n            return;\r\n        }\r\n\r\n        // Error to call it before the start of the plan\r\n        require(block.number >= gradualUpdate.startBlock, \"ERR_CANT_POKE_YET\");\r\n        // Proposed error message improvement\r\n        // require(block.number >= startBlock, \"ERR_NO_HOKEY_POKEY\");\r\n\r\n        // This allows for pokes after endBlock that get weights to endWeights\r\n        // Get the current block (or the endBlock, if we're already past the end)\r\n        uint currentBlock;\r\n        if (block.number > gradualUpdate.endBlock) {\r\n            currentBlock = gradualUpdate.endBlock;\r\n        }\r\n        else {\r\n            currentBlock = block.number;\r\n        }\r\n\r\n        uint blockPeriod = BalancerSafeMath.bsub(gradualUpdate.endBlock, gradualUpdate.startBlock);\r\n        uint blocksElapsed = BalancerSafeMath.bsub(currentBlock, gradualUpdate.startBlock);\r\n        uint weightDelta;\r\n        uint deltaPerBlock;\r\n        uint newWeight;\r\n\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        // This loop contains external calls\r\n        // External calls are to math libraries or the underlying pool, so low risk\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            // Make sure it does nothing if the new and old weights are the same (saves gas)\r\n            // It's a degenerate case if they're *all* the same, but you certainly could have\r\n            // a plan where you only change some of the weights in the set\r\n            if (gradualUpdate.startWeights[i] != gradualUpdate.endWeights[i]) {\r\n                if (gradualUpdate.endWeights[i] < gradualUpdate.startWeights[i]) {\r\n                    // We are decreasing the weight\r\n\r\n                    // First get the total weight delta\r\n                    weightDelta = BalancerSafeMath.bsub(gradualUpdate.startWeights[i],\r\n                                                        gradualUpdate.endWeights[i]);\r\n                    // And the amount it should change per block = total change/number of blocks in the period\r\n                    deltaPerBlock = BalancerSafeMath.bdiv(weightDelta, blockPeriod);\r\n                    //deltaPerBlock = bdivx(weightDelta, blockPeriod);\r\n\r\n                     // newWeight = startWeight - (blocksElapsed * deltaPerBlock)\r\n                    newWeight = BalancerSafeMath.bsub(gradualUpdate.startWeights[i],\r\n                                                      BalancerSafeMath.bmul(blocksElapsed, deltaPerBlock));\r\n                }\r\n                else {\r\n                    // We are increasing the weight\r\n\r\n                    // First get the total weight delta\r\n                    weightDelta = BalancerSafeMath.bsub(gradualUpdate.endWeights[i],\r\n                                                        gradualUpdate.startWeights[i]);\r\n                    // And the amount it should change per block = total change/number of blocks in the period\r\n                    deltaPerBlock = BalancerSafeMath.bdiv(weightDelta, blockPeriod);\r\n                    //deltaPerBlock = bdivx(weightDelta, blockPeriod);\r\n\r\n                     // newWeight = startWeight + (blocksElapsed * deltaPerBlock)\r\n                    newWeight = BalancerSafeMath.badd(gradualUpdate.startWeights[i],\r\n                                                      BalancerSafeMath.bmul(blocksElapsed, deltaPerBlock));\r\n                }\r\n\r\n                uint bal = bPool.getBalance(tokens[i]);\r\n\r\n                bPool.rebind(tokens[i], bal, newWeight);\r\n            }\r\n        }\r\n\r\n        // Reset to allow add/remove tokens, or manual weight updates\r\n        if (block.number >= gradualUpdate.endBlock) {\r\n            gradualUpdate.startBlock = 0;\r\n        }\r\n    }\r\n\r\n    /* solhint-enable function-max-lines */\r\n\r\n    /**\r\n     * @notice Schedule (commit) a token to be added; must call applyAddToken after a fixed\r\n     *         number of blocks to actually add the token\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param token - the token to be added\r\n     * @param balance - how much to be added\r\n     * @param denormalizedWeight - the desired token weight\r\n     * @param newToken - NewTokenParams struct used to hold the token data (in CRP storage)\r\n     */\r\n    function commitAddToken(\r\n        IBPool bPool,\r\n        address token,\r\n        uint balance,\r\n        uint denormalizedWeight,\r\n        NewTokenParams storage newToken\r\n    )\r\n        external\r\n    {\r\n        require(!bPool.isBound(token), \"ERR_IS_BOUND\");\r\n\r\n        require(denormalizedWeight <= BalancerConstants.MAX_WEIGHT, \"ERR_WEIGHT_ABOVE_MAX\");\r\n        require(denormalizedWeight >= BalancerConstants.MIN_WEIGHT, \"ERR_WEIGHT_BELOW_MIN\");\r\n        require(BalancerSafeMath.badd(bPool.getTotalDenormalizedWeight(),\r\n                                      denormalizedWeight) <= BalancerConstants.MAX_TOTAL_WEIGHT,\r\n                \"ERR_MAX_TOTAL_WEIGHT\");\r\n        require(balance >= BalancerConstants.MIN_BALANCE, \"ERR_BALANCE_BELOW_MIN\");\r\n\r\n        newToken.addr = token;\r\n        newToken.balance = balance;\r\n        newToken.denorm = denormalizedWeight;\r\n        newToken.commitBlock = block.number;\r\n        newToken.isCommitted = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the token previously committed (in commitAddToken) to the pool\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param addTokenTimeLockInBlocks -  Wait time between committing and applying a new token\r\n     * @param newToken - NewTokenParams struct used to hold the token data (in CRP storage)\r\n     */\r\n    function applyAddToken(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        uint addTokenTimeLockInBlocks,\r\n        NewTokenParams storage newToken\r\n    )\r\n        external\r\n    {\r\n        require(newToken.isCommitted, \"ERR_NO_TOKEN_COMMIT\");\r\n        require(BalancerSafeMath.bsub(block.number, newToken.commitBlock) >= addTokenTimeLockInBlocks,\r\n                                      \"ERR_TIMELOCK_STILL_COUNTING\");\r\n\r\n        uint totalSupply = self.totalSupply();\r\n\r\n        // poolShares = totalSupply * newTokenWeight / totalWeight\r\n        uint poolShares = BalancerSafeMath.bdiv(BalancerSafeMath.bmul(totalSupply, newToken.denorm),\r\n                                                bPool.getTotalDenormalizedWeight());\r\n\r\n        // Clear this to allow adding more tokens\r\n        newToken.isCommitted = false;\r\n\r\n        // First gets the tokens from msg.sender to this contract (Pool Controller)\r\n        bool returnValue = IERC20(newToken.addr).transferFrom(self.getController(), address(self), newToken.balance);\r\n        require(returnValue, \"ERR_ERC20_FALSE\");\r\n\r\n        // Now with the tokens this contract can bind them to the pool it controls\r\n        // Approves bPool to pull from this controller\r\n        // Approve unlimited, same as when creating the pool, so they can join pools later\r\n        returnValue = SafeApprove.safeApprove(IERC20(newToken.addr), address(bPool), BalancerConstants.MAX_UINT);\r\n        require(returnValue, \"ERR_ERC20_FALSE\");\r\n\r\n        bPool.bind(newToken.addr, newToken.balance, newToken.denorm);\r\n\r\n        self.mintPoolShareFromLib(poolShares);\r\n        self.pushPoolShareFromLib(msg.sender, poolShares);\r\n    }\r\n\r\n     /**\r\n     * @notice Remove a token from the pool\r\n     * @dev Logic in the CRP controls when ths can be called. There are two related permissions:\r\n     *      AddRemoveTokens - which allows removing down to the underlying BPool limit of two\r\n     *      RemoveAllTokens - which allows completely draining the pool by removing all tokens\r\n     *                        This can result in a non-viable pool with 0 or 1 tokens (by design),\r\n     *                        meaning all swapping or binding operations would fail in this state\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param token - token to remove\r\n     */\r\n    function removeToken(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address token\r\n    )\r\n        external\r\n    {\r\n        uint totalSupply = self.totalSupply();\r\n\r\n        // poolShares = totalSupply * tokenWeight / totalWeight\r\n        uint poolShares = BalancerSafeMath.bdiv(BalancerSafeMath.bmul(totalSupply,\r\n                                                                      bPool.getDenormalizedWeight(token)),\r\n                                                bPool.getTotalDenormalizedWeight());\r\n\r\n        // this is what will be unbound from the pool\r\n        // Have to get it before unbinding\r\n        uint balance = bPool.getBalance(token);\r\n\r\n        // Unbind and get the tokens out of balancer pool\r\n        bPool.unbind(token);\r\n\r\n        // Now with the tokens this contract can send them to msg.sender\r\n        bool xfer = IERC20(token).transfer(self.getController(), balance);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n\r\n        self.pullPoolShareFromLib(self.getController(), poolShares);\r\n        self.burnPoolShareFromLib(poolShares);\r\n    }\r\n\r\n    /**\r\n     * @notice Non ERC20-conforming tokens are problematic; don't allow them in pools\r\n     * @dev Will revert if invalid\r\n     * @param token - The prospective token to verify\r\n     */\r\n    function verifyTokenCompliance(address token) external {\r\n        verifyTokenComplianceInternal(token);\r\n    }\r\n\r\n    /**\r\n     * @notice Non ERC20-conforming tokens are problematic; don't allow them in pools\r\n     * @dev Will revert if invalid - overloaded to save space in the main contract\r\n     * @param tokens - The prospective tokens to verify\r\n     */\r\n    function verifyTokenCompliance(address[] calldata tokens) external {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            verifyTokenComplianceInternal(tokens[i]);\r\n         }\r\n    }\r\n\r\n    /**\r\n     * @notice Update weights in a predetermined way, between startBlock and endBlock,\r\n     *         through external cals to pokeWeights\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param newWeights - final weights we want to get to\r\n     * @param startBlock - when weights should start to change\r\n     * @param endBlock - when weights will be at their final values\r\n     * @param minimumWeightChangeBlockPeriod - needed to validate the block period\r\n    */\r\n    function updateWeightsGradually(\r\n        IBPool bPool,\r\n        GradualUpdateParams storage gradualUpdate,\r\n        uint[] calldata newWeights,\r\n        uint startBlock,\r\n        uint endBlock,\r\n        uint minimumWeightChangeBlockPeriod\r\n    )\r\n        external\r\n    {\r\n        require(block.number < endBlock, \"ERR_GRADUAL_UPDATE_TIME_TRAVEL\");\r\n        \r\n        if (block.number > startBlock) {\r\n            // This means the weight update should start ASAP\r\n            // Moving the start block up prevents a big jump/discontinuity in the weights\r\n            gradualUpdate.startBlock = block.number;\r\n        }\r\n        else{\r\n            gradualUpdate.startBlock = startBlock;\r\n        }\r\n\r\n        // Enforce a minimum time over which to make the changes\r\n        // The also prevents endBlock <= startBlock\r\n        require(BalancerSafeMath.bsub(endBlock, gradualUpdate.startBlock) >= minimumWeightChangeBlockPeriod,\r\n                \"ERR_WEIGHT_CHANGE_TIME_BELOW_MIN\");\r\n\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        // Must specify weights for all tokens\r\n        require(newWeights.length == tokens.length, \"ERR_START_WEIGHTS_MISMATCH\");\r\n\r\n        uint weightsSum = 0;\r\n        gradualUpdate.startWeights = new uint[](tokens.length);\r\n\r\n        // Check that endWeights are valid now to avoid reverting in a future pokeWeights call\r\n        //\r\n        // This loop contains external calls\r\n        // External calls are to math libraries or the underlying pool, so low risk\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            require(newWeights[i] <= BalancerConstants.MAX_WEIGHT, \"ERR_WEIGHT_ABOVE_MAX\");\r\n            require(newWeights[i] >= BalancerConstants.MIN_WEIGHT, \"ERR_WEIGHT_BELOW_MIN\");\r\n\r\n            weightsSum = BalancerSafeMath.badd(weightsSum, newWeights[i]);\r\n            gradualUpdate.startWeights[i] = bPool.getDenormalizedWeight(tokens[i]);\r\n        }\r\n        require(weightsSum <= BalancerConstants.MAX_TOTAL_WEIGHT, \"ERR_MAX_TOTAL_WEIGHT\");\r\n\r\n        gradualUpdate.endBlock = endBlock;\r\n        gradualUpdate.endWeights = newWeights;\r\n    }\r\n\r\n    /**\r\n     * @notice Join a pool\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param poolAmountOut - number of pool tokens to receive\r\n     * @param maxAmountsIn - Max amount of asset tokens to spend\r\n     * @return actualAmountsIn - calculated values of the tokens to pull in\r\n     */\r\n    function joinPool(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        uint poolAmountOut,\r\n        uint[] calldata maxAmountsIn\r\n    )\r\n         external\r\n         view\r\n         returns (uint[] memory actualAmountsIn)\r\n    {\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        require(maxAmountsIn.length == tokens.length, \"ERR_AMOUNTS_MISMATCH\");\r\n\r\n        uint poolTotal = self.totalSupply();\r\n        // Subtract  1 to ensure any rounding errors favor the pool\r\n        uint ratio = BalancerSafeMath.bdiv(poolAmountOut,\r\n                                           BalancerSafeMath.bsub(poolTotal, 1));\r\n\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        // We know the length of the array; initialize it, and fill it below\r\n        // Cannot do \"push\" in memory\r\n        actualAmountsIn = new uint[](tokens.length);\r\n\r\n        // This loop contains external calls\r\n        // External calls are to math libraries or the underlying pool, so low risk\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address t = tokens[i];\r\n            uint bal = bPool.getBalance(t);\r\n            // Add 1 to ensure any rounding errors favor the pool\r\n            uint tokenAmountIn = BalancerSafeMath.bmul(ratio,\r\n                                                       BalancerSafeMath.badd(bal, 1));\r\n\r\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\r\n\r\n            actualAmountsIn[i] = tokenAmountIn;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem pool tokens for underlying assets\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param poolAmountIn - amount of pool tokens to redeem\r\n     * @param minAmountsOut - minimum amount of asset tokens to receive\r\n     * @return exitFee - calculated exit fee\r\n     * @return pAiAfterExitFee - final amount in (after accounting for exit fee)\r\n     * @return actualAmountsOut - calculated amounts of each token to pull\r\n     */\r\n    function exitPool(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        uint poolAmountIn,\r\n        uint[] calldata minAmountsOut\r\n    )\r\n        external\r\n        view\r\n        returns (uint exitFee, uint pAiAfterExitFee, uint[] memory actualAmountsOut)\r\n    {\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        require(minAmountsOut.length == tokens.length, \"ERR_AMOUNTS_MISMATCH\");\r\n\r\n        uint poolTotal = self.totalSupply();\r\n\r\n        // Calculate exit fee and the final amount in\r\n        exitFee = BalancerSafeMath.bmul(poolAmountIn, BalancerConstants.EXIT_FEE);\r\n        pAiAfterExitFee = BalancerSafeMath.bsub(poolAmountIn, exitFee);\r\n\r\n        uint ratio = BalancerSafeMath.bdiv(pAiAfterExitFee,\r\n                                           BalancerSafeMath.badd(poolTotal, 1));\r\n\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        actualAmountsOut = new uint[](tokens.length);\r\n\r\n        // This loop contains external calls\r\n        // External calls are to math libraries or the underlying pool, so low risk\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address t = tokens[i];\r\n            uint bal = bPool.getBalance(t);\r\n            // Subtract 1 to ensure any rounding errors favor the pool\r\n            uint tokenAmountOut = BalancerSafeMath.bmul(ratio,\r\n                                                        BalancerSafeMath.bsub(bal, 1));\r\n\r\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\r\n\r\n            actualAmountsOut[i] = tokenAmountOut;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Join by swapping a fixed amount of an external token in (must be present in the pool)\r\n     *         System calculates the pool token amount\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param tokenIn - which token we're transferring in\r\n     * @param tokenAmountIn - amount of deposit\r\n     * @param minPoolAmountOut - minimum of pool tokens to receive\r\n     * @return poolAmountOut - amount of pool tokens minted and transferred\r\n     */\r\n    function joinswapExternAmountIn(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address tokenIn,\r\n        uint tokenAmountIn,\r\n        uint minPoolAmountOut\r\n    )\r\n        external\r\n        view\r\n        returns (uint poolAmountOut)\r\n    {\r\n        require(bPool.isBound(tokenIn), \"ERR_NOT_BOUND\");\r\n        require(tokenAmountIn <= BalancerSafeMath.bmul(bPool.getBalance(tokenIn),\r\n                                                       BalancerConstants.MAX_IN_RATIO),\r\n                                                       \"ERR_MAX_IN_RATIO\");\r\n\r\n        poolAmountOut = bPool.calcPoolOutGivenSingleIn(\r\n                            bPool.getBalance(tokenIn),\r\n                            bPool.getDenormalizedWeight(tokenIn),\r\n                            self.totalSupply(),\r\n                            bPool.getTotalDenormalizedWeight(),\r\n                            tokenAmountIn,\r\n                            bPool.getSwapFee()\r\n                        );\r\n\r\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\r\n    }\r\n\r\n    /**\r\n     * @notice Join by swapping an external token in (must be present in the pool)\r\n     *         To receive an exact amount of pool tokens out. System calculates the deposit amount\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param tokenIn - which token we're transferring in (system calculates amount required)\r\n     * @param poolAmountOut - amount of pool tokens to be received\r\n     * @param maxAmountIn - Maximum asset tokens that can be pulled to pay for the pool tokens\r\n     * @return tokenAmountIn - amount of asset tokens transferred in to purchase the pool tokens\r\n     */\r\n    function joinswapPoolAmountOut(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address tokenIn,\r\n        uint poolAmountOut,\r\n        uint maxAmountIn\r\n    )\r\n        external\r\n        view\r\n        returns (uint tokenAmountIn)\r\n    {\r\n        require(bPool.isBound(tokenIn), \"ERR_NOT_BOUND\");\r\n\r\n        tokenAmountIn = bPool.calcSingleInGivenPoolOut(\r\n                            bPool.getBalance(tokenIn),\r\n                            bPool.getDenormalizedWeight(tokenIn),\r\n                            self.totalSupply(),\r\n                            bPool.getTotalDenormalizedWeight(),\r\n                            poolAmountOut,\r\n                            bPool.getSwapFee()\r\n                        );\r\n\r\n        require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        require(tokenAmountIn <= BalancerSafeMath.bmul(bPool.getBalance(tokenIn),\r\n                                                       BalancerConstants.MAX_IN_RATIO),\r\n                                                       \"ERR_MAX_IN_RATIO\");\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem a specific number of pool tokens for an underlying asset\r\n     *         Asset must be present in the pool, and will incur an EXIT_FEE (if set to non-zero)\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param tokenOut - which token the caller wants to receive\r\n     * @param poolAmountIn - amount of pool tokens to redeem\r\n     * @param minAmountOut - minimum asset tokens to receive\r\n     * @return exitFee - calculated exit fee\r\n     * @return tokenAmountOut - amount of asset tokens returned\r\n     */\r\n    function exitswapPoolAmountIn(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address tokenOut,\r\n        uint poolAmountIn,\r\n        uint minAmountOut\r\n    )\r\n        external\r\n        view\r\n        returns (uint exitFee, uint tokenAmountOut)\r\n    {\r\n        require(bPool.isBound(tokenOut), \"ERR_NOT_BOUND\");\r\n\r\n        tokenAmountOut = bPool.calcSingleOutGivenPoolIn(\r\n                            bPool.getBalance(tokenOut),\r\n                            bPool.getDenormalizedWeight(tokenOut),\r\n                            self.totalSupply(),\r\n                            bPool.getTotalDenormalizedWeight(),\r\n                            poolAmountIn,\r\n                            bPool.getSwapFee()\r\n                        );\r\n\r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n        require(tokenAmountOut <= BalancerSafeMath.bmul(bPool.getBalance(tokenOut),\r\n                                                        BalancerConstants.MAX_OUT_RATIO),\r\n                                                        \"ERR_MAX_OUT_RATIO\");\r\n\r\n        exitFee = BalancerSafeMath.bmul(poolAmountIn, BalancerConstants.EXIT_FEE);\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem pool tokens for a specific amount of underlying assets\r\n     *         Asset must be present in the pool\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param tokenOut - which token the caller wants to receive\r\n     * @param tokenAmountOut - amount of underlying asset tokens to receive\r\n     * @param maxPoolAmountIn - maximum pool tokens to be redeemed\r\n     * @return exitFee - calculated exit fee\r\n     * @return poolAmountIn - amount of pool tokens redeemed\r\n     */\r\n    function exitswapExternAmountOut(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address tokenOut,\r\n        uint tokenAmountOut,\r\n        uint maxPoolAmountIn\r\n    )\r\n        external\r\n        view\r\n        returns (uint exitFee, uint poolAmountIn)\r\n    {\r\n        require(bPool.isBound(tokenOut), \"ERR_NOT_BOUND\");\r\n        require(tokenAmountOut <= BalancerSafeMath.bmul(bPool.getBalance(tokenOut),\r\n                                                        BalancerConstants.MAX_OUT_RATIO),\r\n                                                        \"ERR_MAX_OUT_RATIO\");\r\n        poolAmountIn = bPool.calcPoolInGivenSingleOut(\r\n                            bPool.getBalance(tokenOut),\r\n                            bPool.getDenormalizedWeight(tokenOut),\r\n                            self.totalSupply(),\r\n                            bPool.getTotalDenormalizedWeight(),\r\n                            tokenAmountOut,\r\n                            bPool.getSwapFee()\r\n                        );\r\n\r\n        require(poolAmountIn != 0, \"ERR_MATH_APPROX\");\r\n        require(poolAmountIn <= maxPoolAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        exitFee = BalancerSafeMath.bmul(poolAmountIn, BalancerConstants.EXIT_FEE);\r\n    }\r\n\r\n    // Internal functions\r\n\r\n    // Check for zero transfer, and make sure it returns true to returnValue\r\n    function verifyTokenComplianceInternal(address token) internal {\r\n        bool returnValue = IERC20(token).transfer(msg.sender, 0);\r\n        require(returnValue, \"ERR_NONCONFORMING_TOKEN\");\r\n    }\r\n}\r\n"
    },
    "libraries/SafeApprove.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n// Imports\r\n\r\nimport \"../interfaces/IERC20.sol\";\r\n\r\n// Libraries\r\n\r\n/**\r\n * @author PieDAO (ported to Balancer Labs)\r\n * @title SafeApprove - set approval for tokens that require 0 prior approval\r\n * @dev Perhaps to address the known ERC20 race condition issue\r\n *      See https://github.com/crytic/not-so-smart-contracts/tree/master/race_condition\r\n *      Some tokens - notably KNC - only allow approvals to be increased from 0\r\n */\r\nlibrary SafeApprove {\r\n    /**\r\n     * @notice handle approvals of tokens that require approving from a base of 0\r\n     * @param token - the token we're approving\r\n     * @param spender - entity the owner (sender) is approving to spend his tokens\r\n     * @param amount - number of tokens being approved\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        uint256 currentAllowance = token.allowance(address(this), spender);\r\n\r\n        // Do nothing if allowance is already set to this value\r\n        if (currentAllowance == amount) {\r\n            return true;\r\n        }\r\n\r\n        // If approval is not zero reset it to zero first\r\n        if (currentAllowance != 0) {\r\n            // return token.approve(spender, 0);\r\n            // FCX: fixed, do not returns\r\n            // base on BActions._safeApprove\r\n            token.approve(spender, 0);\r\n        }\r\n\r\n        // do the actual approval\r\n        return token.approve(spender, amount);\r\n    }\r\n}\r\n"
    },
    "libraries/BalancerSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n\r\n// Imports\r\n\r\nimport \"./BalancerConstants.sol\";\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title SafeMath - wrap Solidity operators to prevent underflow/overflow\r\n * @dev badd and bsub are basically identical to OpenZeppelin SafeMath; mul/div have extra checks\r\n */\r\nlibrary BalancerSafeMath {\r\n    /**\r\n     * @notice Safe addition\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @dev if we are adding b to a, the resulting sum must be greater than a\r\n     * @return - sum of operands; throws if overflow\r\n     */\r\n    function badd(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned subtraction\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @dev Do a signed subtraction, and check that it produces a positive value\r\n     *      (i.e., a - b is valid if b <= a)\r\n     * @return - a - b; throws if underflow\r\n     */\r\n    function bsub(uint a, uint b) internal pure returns (uint) {\r\n        (uint c, bool negativeResult) = bsubSign(a, b);\r\n        require(!negativeResult, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe signed subtraction\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @dev Do a signed subtraction\r\n     * @return - difference between a and b, and a flag indicating a negative result\r\n     *           (i.e., a - b if a is greater than or equal to b; otherwise b - a)\r\n     */\r\n    function bsubSign(uint a, uint b) internal pure returns (uint, bool) {\r\n        if (b <= a) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Safe multiplication\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @dev Multiply safely (and efficiently), rounding down\r\n     * @return - product of operands; throws if overflow or rounding error\r\n     */\r\n    function bmul(uint a, uint b) internal pure returns (uint) {\r\n        // Gas optimization (see github.com/OpenZeppelin/openzeppelin-contracts/pull/522)\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Standard overflow check: a/a*b=b\r\n        uint c0 = a * b;\r\n        require(c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n\r\n        // Round to 0 if x*y < BONE/2?\r\n        uint c1 = c0 + (BalancerConstants.BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint c2 = c1 / BalancerConstants.BONE;\r\n        return c2;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe division\r\n     * @param dividend - first operand\r\n     * @param divisor - second operand\r\n     * @dev Divide safely (and efficiently), rounding down\r\n     * @return - quotient; throws if overflow or rounding error\r\n     */\r\n    function bdiv(uint dividend, uint divisor) internal pure returns (uint) {\r\n        require(divisor != 0, \"ERR_DIV_ZERO\");\r\n\r\n        // Gas optimization\r\n        if (dividend == 0){\r\n            return 0;\r\n        }\r\n\r\n        uint c0 = dividend * BalancerConstants.BONE;\r\n        require(c0 / dividend == BalancerConstants.BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n\r\n        uint c1 = c0 + (divisor / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n\r\n        uint c2 = c1 / divisor;\r\n        return c2;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned integer modulo\r\n     * @dev Returns the remainder of dividing two unsigned integers.\r\n     *      Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * @param dividend - first operand\r\n     * @param divisor - second operand -- cannot be zero\r\n     * @return - quotient; throws if overflow or rounding error\r\n     */\r\n    function bmod(uint dividend, uint divisor) internal pure returns (uint) {\r\n        require(divisor != 0, \"ERR_MODULO_BY_ZERO\");\r\n\r\n        return dividend % divisor;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned integer max\r\n     * @dev Returns the greater of the two input values\r\n     *\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @return - the maximum of a and b\r\n     */\r\n    function bmax(uint a, uint b) internal pure returns (uint) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned integer min\r\n     * @dev returns b, if b < a; otherwise returns a\r\n     *\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @return - the lesser of the two input values\r\n     */\r\n    function bmin(uint a, uint b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned integer average\r\n     * @dev Guard against (a+b) overflow by dividing each operand separately\r\n     *\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @return - the average of the two values\r\n     */\r\n    function baverage(uint a, uint b) internal pure returns (uint) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n\r\n    /**\r\n     * @notice Babylonian square root implementation\r\n     * @dev (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n     * @param y - operand\r\n     * @return z - the square root result\r\n     */\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        }\r\n        else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n"
    },
    "interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n// Interface declarations\r\n\r\n/* solhint-disable func-order */\r\n\r\ninterface IERC20 {\r\n    // Emitted when the allowance of a spender for an owner is set by a call to approve.\r\n    // Value is the new allowance\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    // Emitted when value tokens are moved from one account (from) to another (to).\r\n    // Note that value may be zero\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    // Returns the amount of tokens in existence\r\n    function totalSupply() external view returns (uint);\r\n\r\n    // Returns the amount of tokens owned by account\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    // Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner\r\n    // through transferFrom. This is zero by default\r\n    // This value changes when approve or transferFrom are called\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    // Sets amount as the allowance of spender over the callers tokens\r\n    // Returns a boolean value indicating whether the operation succeeded\r\n    // Emits an Approval event.\r\n    function approve(address spender, uint amount) external returns (bool);\r\n\r\n    // Moves amount tokens from the callers account to recipient\r\n    // Returns a boolean value indicating whether the operation succeeded\r\n    // Emits a Transfer event.\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n\r\n    // Moves amount tokens from sender to recipient using the allowance mechanism\r\n    // Amount is then deducted from the callers allowance\r\n    // Returns a boolean value indicating whether the operation succeeded\r\n    // Emits a Transfer event\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n}\r\n"
    },
    "libraries/BalancerConstants.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Put all the constants in one place\r\n */\r\n\r\nlibrary BalancerConstants {\r\n    // State variables (must be constant in a library)\r\n\r\n    // B \"ONE\" - all math is in the \"realm\" of 10 ** 18;\r\n    // where numeric 1 = 10 ** 18\r\n    uint256 public constant BONE = 10**18;\r\n    uint256 public constant MIN_WEIGHT = BONE;\r\n    uint256 public constant MAX_WEIGHT = BONE * 50;\r\n    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\r\n    uint256 public constant MIN_BALANCE = BONE / 10**6;\r\n    uint256 public constant MAX_BALANCE = BONE * 10**12;\r\n    uint256 public constant MIN_POOL_SUPPLY = BONE * 100;\r\n    uint256 public constant MAX_POOL_SUPPLY = BONE * 10**9;\r\n    uint256 public constant MIN_FEE = BONE / 10**6;\r\n    // uint256 public constant MAX_FEE = BONE / 10;\r\n    // FCX: max fee is 100%\r\n    uint256 public constant MAX_FEE = BONE;\r\n    // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\r\n    uint256 public constant EXIT_FEE = 0;\r\n    uint256 public constant MAX_IN_RATIO = BONE / 2;\r\n    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\r\n    // Must match BConst.MIN_BOUND_TOKENS and BConst.MAX_BOUND_TOKENS\r\n    uint256 public constant MIN_ASSET_LIMIT = 2;\r\n    uint256 public constant MAX_ASSET_LIMIT = 8;\r\n    uint256 public constant MAX_UINT = uint256(-1);\r\n}\r\n"
    },
    "interfaces/IConfigurableRightsPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n// Interface declarations\r\n\r\n// Introduce to avoid circularity (otherwise, the CRP and SmartPoolManager include each other)\r\n// Removing circularity allows flattener tools to work, which enables Etherscan verification\r\ninterface IConfigurableRightsPool {\r\n    enum Permissions {\r\n        PAUSE_SWAPPING,\r\n        CHANGE_SWAP_FEE,\r\n        CHANGE_WEIGHTS,\r\n        ADD_REMOVE_TOKENS,\r\n        WHITELIST_LPS,\r\n        CHANGE_CAP,\r\n        CHANGE_PROTOCOL_FEE\r\n    }\r\n\r\n    struct Rights {\r\n        bool canPauseSwapping;\r\n        bool canChangeSwapFee;\r\n        bool canChangeWeights;\r\n        bool canAddRemoveTokens;\r\n        bool canWhitelistLPs;\r\n        bool canChangeCap;\r\n        bool canChangeProtocolFee;\r\n    }\r\n\r\n    function mintPoolShareFromLib(uint256 amount) external;\r\n\r\n    function pushPoolShareFromLib(address to, uint256 amount) external;\r\n\r\n    function pullPoolShareFromLib(address from, uint256 amount) external;\r\n\r\n    function burnPoolShareFromLib(uint256 amount) external;\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function getController() external view returns (address);\r\n\r\n    function setSwapFee(uint256 swapFee) external;\r\n\r\n    function setProtocolFee(uint256 protocolFee) external;\r\n\r\n    function setRoles(bytes32[] memory roles) external;\r\n\r\n    function setAccessControlAddress(address accessAddress) external;\r\n\r\n    function setPublicSwap(bool publicSwap) external;\r\n\r\n    function setCap(uint256 newCap) external;\r\n\r\n    function isPublicSwap() external view returns (bool);\r\n\r\n    function createPool(\r\n        uint256,\r\n        uint256,\r\n        uint256\r\n    ) external;\r\n\r\n    function createPool(uint256) external;\r\n\r\n    function updateWeight(address, uint256) external;\r\n\r\n    function updateWeightsGradually(\r\n        uint256[] calldata,\r\n        uint256,\r\n        uint256\r\n    ) external;\r\n\r\n    function pokeWeights() external;\r\n\r\n    function commitAddToken(\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external;\r\n\r\n    function applyAddToken() external;\r\n\r\n    function removeToken(address) external;\r\n\r\n    function joinPool(uint256, uint256[] calldata) external;\r\n\r\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\r\n\r\n    function joinswapExternAmountIn(\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256 poolAmountOut);\r\n\r\n    function joinswapPoolAmountOut(\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256 tokenAmountIn);\r\n\r\n    function exitswapPoolAmountIn(\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256 tokenAmountOut);\r\n\r\n    function exitswapExternAmountOut(\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256 poolAmountIn);\r\n\r\n    function whitelistLiquidityProvider(address[] calldata) external;\r\n\r\n    function removeWhitelistedLiquidityProvider(address[] calldata) external;\r\n\r\n    function canProvideLiquidity(address) external view returns (bool);\r\n\r\n    function hasPermission(Permissions) external view returns (bool);\r\n\r\n    function getDenormalizedWeight(address) external view returns (uint256);\r\n\r\n    function getRightsManagerVersion() external pure returns (address);\r\n\r\n    function getBalancerSafeMathVersion() external pure returns (address);\r\n\r\n    function getSmartPoolManagerVersion() external pure returns (address);\r\n\r\n    function createPoolInternal(uint256) external;\r\n\r\n    function approve(address, uint256) external;\r\n\r\n    function bspCap() external view returns (uint256);\r\n\r\n    function bPool() external view returns (address);\r\n\r\n    function rights() external view returns (Rights memory);\r\n\r\n    // erc20\r\n    function balanceOf(address) external view returns (uint256);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function allowance(address, address) external view returns (uint256);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function transferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external returns (bool);\r\n\r\n    function increaseApproval(address, uint256) external returns (bool);\r\n\r\n    function decreaseApproval(address, uint256) external returns (bool);\r\n\r\n    function transfer(address, uint256) external returns (bool);\r\n\r\n    function setCanWhitelistLPs(bool) external;\r\n}\r\n"
    },
    "contracts/templates/ElasticSupplyPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n// Needed to handle structures externally\r\npragma experimental ABIEncoderV2;\r\n\r\n// Imports\r\n\r\nimport \"../IBFactory.sol\";\r\nimport \"../PCToken.sol\";\r\nimport \"../utils/BalancerReentrancyGuard.sol\";\r\nimport \"../utils/BalancerOwnable.sol\";\r\nimport \"../ConfigurableRightsPool.sol\";\r\n\r\n// Interfaces\r\n\r\n// Libraries\r\nimport {RightsManager} from \"../../libraries/RightsManager.sol\";\r\n\r\n// Contracts\r\n\r\n/**\r\n * @author Ampleforth engineering team & Balancer Labs\r\n *\r\n * Reference:\r\n * https://github.com/balancer-labs/configurable-rights-pool/blob/master/contracts/templates/ElasticSupplyPool.sol\r\n *\r\n * @title Ampl Elastic Configurable Rights Pool.\r\n *\r\n * @dev   Extension of Balancer labs' configurable rights pool (smart-pool).\r\n *        Amples are a dynamic supply tokens, supply and individual balances change daily by a Rebase operation.\r\n *        In constant-function markets, Ampleforth's supply adjustments result in Impermanent Loss (IL)\r\n *        to liquidity providers. The AmplElasticCRP is an extension of Balancer Lab's\r\n *        ConfigurableRightsPool which mitigates IL induced by supply adjustments.\r\n *\r\n *        It accomplishes this by doing the following mechanism:\r\n *        The `resyncWeight` method will be invoked atomically after rebase through Ampleforth's orchestrator.\r\n *\r\n *        When rebase changes supply, ampl weight is updated to the geometric mean of\r\n *        the current ampl weight and the target. Every other token's weight is updated\r\n *        proportionally such that relative ratios are same.\r\n *\r\n *        Weights: {w_ampl, w_t1 ... w_tn}\r\n *\r\n *        Rebase_change: x% (Ample's supply changes by x%, can be positive or negative)\r\n *\r\n *        Ample target weight: w_ampl_target = (100+x)/100 * w_ampl\r\n *\r\n *        w_ampl_new = sqrt(w_ampl * w_ampl_target)  // geometric mean\r\n *        for i in tn:\r\n *           w_ti_new = (w_ampl_new * w_ti) / w_ampl_target\r\n *\r\n */\r\ncontract ElasticSupplyPool is ConfigurableRightsPool {\r\n    using BalancerSafeMath for uint256;\r\n\r\n    // Event declarations\r\n\r\n    // Have to redeclare in the subclass, to be emitted from this contract\r\n\r\n    event LogCall(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\r\n\r\n    event LogJoin(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\r\n\r\n    event LogExit(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\r\n\r\n    // Modifiers\r\n\r\n    // Function declarations\r\n\r\n    /**\r\n     * @notice Construct a new Configurable Rights Pool (wrapper around BPool)\r\n     * @param factoryAddress - the BPoolFactory used to create the underlying pool\r\n     * @param poolParams - CRP pool parameters\r\n     * @param rightsParams - Set of permissions we are assigning to this smart pool\r\n     */\r\n    constructor(\r\n        address factoryAddress,\r\n        ConfigurableRightsPool.PoolParams memory poolParams,\r\n        RightsManager.Rights memory rightsParams\r\n    )\r\n        public\r\n        // solhint-disable-next-line visibility-modifier-order\r\n        ConfigurableRightsPool(factoryAddress, address(0), poolParams, rightsParams)\r\n    {\r\n        require(rightsParams.canChangeWeights, \"ERR_NOT_CONFIGURABLE_WEIGHTS\");\r\n    }\r\n\r\n    // External functions\r\n\r\n    /**\r\n     * @notice ElasticSupply pools don't have updateWeightsGradually, so cannot call this\r\n     * param initialSupply starting token balance\r\n     * param minimumWeightChangeBlockPeriod - Enforce a minimum time between the start and end blocks\r\n     * param addTokenTimeLockInBlocks - Enforce a mandatory wait time between updates\r\n     *                                   This is also the wait time between committing and applying a new token\r\n     */\r\n    function createPool(\r\n        uint256, // initialSupply\r\n        uint256, // minimumWeightChangeBlockPeriod\r\n        uint256 // addTokenTimeLockInBlocks\r\n    ) external override {\r\n        revert(\"ERR_UNSUPPORTED_OPERATION\");\r\n    }\r\n\r\n    /**\r\n     * @notice Update the weight of an existing token - cannot do this in ElasticSupplyPools\r\n     * param token - token to be reweighted\r\n     * param newWeight - new weight of the token\r\n     */\r\n    function updateWeight(\r\n        address, // token\r\n        uint256 // newWeight\r\n    ) external override logs onlyOwner needsBPool {\r\n        revert(\"ERR_UNSUPPORTED_OPERATION\");\r\n    }\r\n\r\n    /**\r\n     * @notice Update weights in a predetermined way, between startBlock and endBlock,\r\n     *         through external calls to pokeWeights -- cannot do this in ElasticSupplyPools\r\n     * @dev Makes sure we aren't already in a weight update scheme\r\n     *      Must call pokeWeights at least once past the end for it to do the final update\r\n     *      and enable calling this again. (Could make this check for that case, but unwarranted complexity.)\r\n     * param newWeights - final weights we want to get to\r\n     * param startBlock - when weights should start to change\r\n     * param endBlock - when weights will be at their final values\r\n     */\r\n    function updateWeightsGradually(\r\n        uint256[] calldata, // newWeights\r\n        uint256, // startBlock\r\n        uint256 // endBlock\r\n    ) external override logs onlyOwner needsBPool {\r\n        revert(\"ERR_UNSUPPORTED_OPERATION\");\r\n    }\r\n\r\n    /**\r\n     * @notice External function called to make the contract update weights according to plan\r\n     *         Unsupported in ElasticSupplyPools\r\n     */\r\n    function pokeWeights() external override logs needsBPool {\r\n        revert(\"ERR_UNSUPPORTED_OPERATION\");\r\n    }\r\n\r\n    /**\r\n     * @notice Update the weight of a token without changing the price (or transferring tokens)\r\n     * @param token The address of the token in the underlying BPool to be weight adjusted.\r\n     * @dev Checks if the token's current pool balance has deviated from cached balance,\r\n     *      if so it adjusts the token's weights proportional to the deviation.\r\n     *      The underlying BPool enforces bounds on MIN_WEIGHTS=1e18, MAX_WEIGHT=50e18 and TOTAL_WEIGHT=50e18.\r\n     *      NOTE: The BPool.rebind function CAN REVERT if the updated weights go beyond the enforced bounds.\r\n     */\r\n    function resyncWeight(address token) external virtual logs lock needsBPool {\r\n        require(gradualUpdate.startBlock == 0, \"ERR_NO_UPDATE_DURING_GRADUAL\");\r\n        require(IBPool(address(bPool)).isBound(token), \"ERR_NOT_BOUND\");\r\n\r\n        // get cached balance\r\n        uint256 tokenBalanceBefore = IBPool(address(bPool)).getBalance(token);\r\n\r\n        // sync balance\r\n        IBPool(address(bPool)).gulp(token);\r\n\r\n        // get new balance\r\n        uint256 tokenBalanceAfter = IBPool(address(bPool)).getBalance(token);\r\n\r\n        // No-Op\r\n        if (tokenBalanceBefore == tokenBalanceAfter) {\r\n            return;\r\n        }\r\n\r\n        // current token weight\r\n        uint256 tokenWeightBefore = IBPool(address(bPool)).getDenormalizedWeight(token);\r\n\r\n        // target token weight = RebaseRatio * previous token weight\r\n        uint256 tokenWeightTarget = BalancerSafeMath.bdiv(\r\n            BalancerSafeMath.bmul(tokenWeightBefore, tokenBalanceAfter),\r\n            tokenBalanceBefore\r\n        );\r\n\r\n        // new token weight = sqrt(current token weight * target token weight)\r\n        uint256 tokenWeightAfter = BalancerSafeMath.sqrt(\r\n            BalancerSafeMath.bdiv(BalancerSafeMath.bmul(tokenWeightBefore, tokenWeightTarget), 1)\r\n        );\r\n\r\n        address[] memory tokens = IBPool(address(bPool)).getCurrentTokens();\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            if (tokens[i] == token) {\r\n                // adjust weight\r\n                IBPool(address(bPool)).rebind(token, tokenBalanceAfter, tokenWeightAfter);\r\n            } else {\r\n                uint256 otherWeightBefore = IBPool(address(bPool)).getDenormalizedWeight(tokens[i]);\r\n                uint256 otherBalance = bPool.getBalance(tokens[i]);\r\n\r\n                // other token weight = (new token weight * other token weight before) / target token weight\r\n                uint256 otherWeightAfter = BalancerSafeMath.bdiv(\r\n                    BalancerSafeMath.bmul(tokenWeightAfter, otherWeightBefore),\r\n                    tokenWeightTarget\r\n                );\r\n\r\n                // adjust weight\r\n                IBPool(address(bPool)).rebind(tokens[i], otherBalance, otherWeightAfter);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/templates/ESPFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n// Needed to handle structures externally\r\npragma experimental ABIEncoderV2;\r\n\r\n// Imports\r\n\r\nimport \"./ElasticSupplyPool.sol\";\r\n\r\n// Contracts\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Configurable Rights Pool Factory - create parameterized smart pools\r\n * @dev Rights are held in a corresponding struct in ConfigurableRightsPool\r\n *      Index values are as follows:\r\n *      0: canPauseSwapping - can setPublicSwap back to false after turning it on\r\n *                            by default, it is off on initialization and can only be turned on\r\n *      1: canChangeSwapFee - can setSwapFee after initialization (by default, it is fixed at create time)\r\n *      2: canChangeWeights - can bind new token weights (allowed by default in base pool)\r\n *      3: canAddRemoveTokens - can bind/unbind tokens (allowed by default in base pool)\r\n *      4: canWhitelistLPs - if set, only whitelisted addresses can join pools\r\n *                           (enables private pools with more than one LP)\r\n */\r\ncontract ESPFactory {\r\n    // State variables\r\n\r\n    // Keep a list of all Elastic Supply Pools\r\n    mapping(address => bool) private _isEsp;\r\n\r\n    // Event declarations\r\n\r\n    // Log the address of each new smart pool, and its creator\r\n    event LogNewEsp(address indexed caller, address indexed pool);\r\n\r\n    // Function declarations\r\n\r\n    /**\r\n     * @notice Create a new ESP\r\n     * @dev emits a LogNewESP event\r\n     * @param factoryAddress - the BFactory instance used to create the underlying pool\r\n     * @param poolParams - CRP pool parameters\r\n     * @param rights - struct of permissions, configuring this CRP instance (see above for definitions)\r\n     */\r\n    function newEsp(\r\n        address factoryAddress,\r\n        ConfigurableRightsPool.PoolParams calldata poolParams,\r\n        RightsManager.Rights calldata rights\r\n    ) external returns (ElasticSupplyPool) {\r\n        require(poolParams.constituentTokens.length >= BalancerConstants.MIN_ASSET_LIMIT, \"ERR_TOO_FEW_TOKENS\");\r\n\r\n        // Arrays must be parallel\r\n        require(poolParams.tokenBalances.length == poolParams.constituentTokens.length, \"ERR_START_BALANCES_MISMATCH\");\r\n        require(poolParams.tokenWeights.length == poolParams.constituentTokens.length, \"ERR_START_WEIGHTS_MISMATCH\");\r\n\r\n        ElasticSupplyPool esp = new ElasticSupplyPool(factoryAddress, poolParams, rights);\r\n\r\n        emit LogNewEsp(msg.sender, address(esp));\r\n\r\n        _isEsp[address(esp)] = true;\r\n        esp.setController(msg.sender);\r\n\r\n        return esp;\r\n    }\r\n\r\n    /**\r\n     * @notice Check to see if a given address is an ESP\r\n     * @param addr - address to check\r\n     * @return boolean indicating whether it is an ESP\r\n     */\r\n    function isEsp(address addr) external view returns (bool) {\r\n        return _isEsp[addr];\r\n    }\r\n}\r\n"
    },
    "contracts/ConfigurableRightsPoolExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n// Imports\r\n\r\nimport \"./IBFactory.sol\";\r\nimport \"./PCToken.sol\";\r\nimport \"./utils/BalancerReentrancyGuard.sol\";\r\nimport \"./utils/BalancerOwnable.sol\";\r\n\r\n// Libraries\r\nimport {RightsManager} from \"../libraries/RightsManager.sol\";\r\nimport \"../libraries/SmartPoolManager.sol\";\r\nimport \"../libraries/SafeApprove.sol\";\r\n\r\ncontract ConfigurableRightsPoolExtension is PCToken, BalancerOwnable, BalancerReentrancyGuard {\r\n    using BalancerSafeMath for uint256;\r\n    using SafeApprove for IERC20;\r\n\r\n    // Type declarations\r\n\r\n    struct PoolParams {\r\n        // Balancer Pool Token (representing shares of the pool)\r\n        string poolTokenSymbol;\r\n        string poolTokenName;\r\n        // Tokens inside the Pool\r\n        address[] constituentTokens;\r\n        uint256[] tokenBalances;\r\n        uint256[] tokenWeights;\r\n        uint256 swapFee;\r\n        uint256 protocolFee;\r\n    }\r\n\r\n    // State variables\r\n\r\n    IBFactory public bFactory;\r\n    IBPool public bPool;\r\n\r\n    // Struct holding the rights configuration\r\n    RightsManager.Rights public rights;\r\n\r\n    // Hold the parameters used in updateWeightsGradually\r\n    SmartPoolManager.GradualUpdateParams public gradualUpdate;\r\n\r\n    // This is for adding a new (currently unbound) token to the pool\r\n    // It's a two-step process: commitAddToken(), then applyAddToken()\r\n    SmartPoolManager.NewTokenParams public newToken;\r\n\r\n    // Fee is initialized on creation, and can be changed if permission is set\r\n    // Only needed for temporary storage between construction and createPool\r\n    // Thereafter, the swap fee should always be read from the underlying pool\r\n    uint256 private _initialSwapFee;\r\n\r\n    uint256 private _initialProtocolFee;\r\n\r\n    address private _initialAccessAddress;\r\n\r\n    // Store the list of tokens in the pool, and balances\r\n    // NOTE that the token list is *only* used to store the pool tokens between\r\n    //   construction and createPool - thereafter, use the underlying BPool's list\r\n    //   (avoids synchronization issues)\r\n    address[] private _initialTokens;\r\n    uint256[] private _initialBalances;\r\n\r\n    // Enforce a minimum time between the start and end blocks\r\n    uint256 public minimumWeightChangeBlockPeriod;\r\n    // Enforce a mandatory wait time between updates\r\n    // This is also the wait time between committing and applying a new token\r\n    uint256 public addTokenTimeLockInBlocks;\r\n\r\n    // Whitelist of LPs (if configured)\r\n    mapping(address => bool) private _liquidityProviderWhitelist;\r\n\r\n    // Cap on the pool size (i.e., # of tokens minted when joining)\r\n    // Limits the risk of experimental pools; failsafe/backup for fixed-size pools\r\n    uint256 public bspCap;\r\n\r\n    // Event declarations\r\n\r\n    // Anonymous logger event - can only be filtered by contract address\r\n\r\n    event LogCall(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\r\n\r\n    event LogJoin(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\r\n\r\n    event LogExit(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\r\n\r\n    event CapChanged(address indexed caller, uint256 oldCap, uint256 newCap);\r\n\r\n    event NewTokenCommitted(address indexed token, address indexed pool, address indexed caller);\r\n\r\n    // Modifiers\r\n\r\n    modifier logs() {\r\n        emit LogCall(msg.sig, msg.sender, msg.data);\r\n        _;\r\n    }\r\n\r\n    // Mark functions that require delegation to the underlying Pool\r\n    modifier needsBPool() {\r\n        require(address(bPool) != address(0), \"ERR_NOT_CREATED\");\r\n        _;\r\n    }\r\n\r\n    modifier lockUnderlyingPool() {\r\n        // Turn off swapping on the underlying pool during joins\r\n        // Otherwise tokens with callbacks would enable attacks involving simultaneous swaps and joins\r\n        bool origSwapState = bPool.isPublicSwap();\r\n        bPool.setPublicSwap(false);\r\n        _;\r\n        bPool.setPublicSwap(origSwapState);\r\n    }\r\n\r\n    // Default values for these variables (used only in updateWeightsGradually), set in the constructor\r\n    // Pools without permission to update weights cannot use them anyway, and should call\r\n    //   the default createPool() function.\r\n    // To override these defaults, pass them into the overloaded createPool()\r\n    // Period is in blocks; 500 blocks ~ 2 hours; 90,000 blocks ~ 2 weeks\r\n    uint256 public constant DEFAULT_MIN_WEIGHT_CHANGE_BLOCK_PERIOD = 90000;\r\n    uint256 public constant DEFAULT_ADD_TOKEN_TIME_LOCK_IN_BLOCKS = 500;\r\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    constructor() public PCToken(\"FCX\", \"FCX\") {}\r\n\r\n    // External functions\r\n\r\n    /**\r\n     * @notice Set the swap fee on the underlying pool\r\n     * @dev Keep the local version and core in sync (see below)\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @param swapFee in Wei\r\n     */\r\n    function setSwapFee(uint256 swapFee) external virtual logs lock onlyOwner needsBPool {\r\n        require(rights.canChangeSwapFee, \"ERR_NOT_CONFIGURABLE_SWAP_FEE\");\r\n\r\n        // Underlying pool will check against min/max fee\r\n        bPool.setSwapFee(swapFee);\r\n    }\r\n\r\n    function setProtocolFee(uint256 protocolFee) external virtual logs lock onlyOwner needsBPool {\r\n        require(rights.canChangeProtocolFee, \"ERR_NOT_CONFIGURABLE_PROTOCOL_FEE\");\r\n\r\n        // Underlying pool will check against min/max fee\r\n        bPool.setProtocolFee(protocolFee);\r\n    }\r\n\r\n    function setRoles(bytes32[] memory roles) external virtual logs lock onlyOwner needsBPool {\r\n        bPool.setRoles(roles);\r\n    }\r\n\r\n    function setAccessControlAddress(address accessAddress) external logs lock onlyOwner needsBPool {\r\n        bPool.setAccessControlAddress(accessAddress);\r\n        _initialAccessAddress = accessAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the public swap flag on the underlying pool\r\n     * @dev If this smart pool has canPauseSwapping enabled, we can turn publicSwap off if it's already on\r\n     *      Note that if they turn swapping off - but then finalize the pool - finalizing will turn the\r\n     *      swapping back on. They're not supposed to finalize the underlying pool... would defeat the\r\n     *      smart pool functions. (Only the owner can finalize the pool - which is this contract -\r\n     *      so there is no risk from outside.)\r\n     *\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @param publicSwap new value of the swap\r\n     */\r\n    function setPublicSwap(bool publicSwap) external virtual logs lock onlyOwner needsBPool {\r\n        require(rights.canPauseSwapping, \"ERR_NOT_PAUSABLE_SWAP\");\r\n\r\n        bPool.setPublicSwap(publicSwap);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the publicSwap field on the underlying pool\r\n     * @dev viewLock, because setPublicSwap is lock\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @return Current value of isPublicSwap\r\n     */\r\n    function isPublicSwap() external view virtual viewlock needsBPool returns (bool) {\r\n        return bPool.isPublicSwap();\r\n    }\r\n\r\n    function setCanWhitelistLPs(bool _canChangeSwapFee) external virtual logs lock onlyOwner needsBPool {\r\n        require(rights.canWhitelistLPs == !_canChangeSwapFee, \"ALREADY_SET\");\r\n        rights.canWhitelistLPs = _canChangeSwapFee;\r\n    }\r\n\r\n    /**\r\n     * @notice Add to the whitelist of liquidity providers (if enabled)\r\n     * @param providers - addresses of the liquidity provider\r\n     */\r\n    function whitelistLiquidityProvider(address[] calldata providers) external onlyOwner lock logs {\r\n        require(rights.canWhitelistLPs, \"ERR_CANNOT_WHITELIST_LPS\");\r\n        for (uint256 i = 0; i < providers.length; i++) {\r\n            address provider = providers[i];\r\n            require(provider != address(0), \"ERR_INVALID_ADDRESS\");\r\n\r\n            _liquidityProviderWhitelist[provider] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Remove from the whitelist of liquidity providers (if enabled)\r\n     * @param providers - addresses of the liquidity provider\r\n     */\r\n    function removeWhitelistedLiquidityProvider(address[] calldata providers) external onlyOwner lock logs {\r\n        require(rights.canWhitelistLPs, \"ERR_CANNOT_WHITELIST_LPS\");\r\n        for (uint256 i = 0; i < providers.length; i++) {\r\n            address provider = providers[i];\r\n            require(_liquidityProviderWhitelist[provider], \"ERR_LP_NOT_WHITELISTED\");\r\n            require(provider != address(0), \"ERR_INVALID_ADDRESS\");\r\n\r\n            _liquidityProviderWhitelist[provider] = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Check if an address is a liquidity provider\r\n     * @dev If the whitelist feature is not enabled, anyone can provide liquidity (assuming finalized)\r\n     * @return boolean value indicating whether the address can join a pool\r\n     */\r\n    function canProvideLiquidity(address provider) external view returns (bool) {\r\n        if (rights.canWhitelistLPs) {\r\n            return _liquidityProviderWhitelist[provider];\r\n        } else {\r\n            // Probably don't strictly need this (could just return true)\r\n            // But the null address can't provide funds\r\n            return provider != address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the denormalized weight of a token\r\n     * @dev viewlock to prevent calling if it's being updated\r\n     * @return token weight\r\n     */\r\n    function getDenormalizedWeight(address token) external view viewlock needsBPool returns (uint256) {\r\n        return bPool.getDenormalizedWeight(token);\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/BalancerSafeMathMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n// Imports\r\n\r\nimport \"../../libraries/BalancerSafeMath.sol\";\r\n\r\n// Contracts\r\n\r\n/*\r\n * @author Balancer Labs\r\n * @title Wrap BalancerSafeMath for testing\r\n */\r\ncontract BalancerSafeMathMock {\r\n    function bmul(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return BalancerSafeMath.bmul(a, b);\r\n    }\r\n\r\n    function bdiv(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return BalancerSafeMath.bdiv(a, b);\r\n    }\r\n\r\n    function bsub(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return BalancerSafeMath.bsub(a, b);\r\n    }\r\n\r\n    function badd(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return BalancerSafeMath.badd(a, b);\r\n    }\r\n\r\n    function bmod(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return BalancerSafeMath.bmod(a, b);\r\n    }\r\n\r\n    function bmax(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return BalancerSafeMath.bmax(a, b);\r\n    }\r\n\r\n    function bmin(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return BalancerSafeMath.bmin(a, b);\r\n    }\r\n\r\n    function baverage(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return BalancerSafeMath.baverage(a, b);\r\n    }\r\n}\r\n"
    },
    "contracts/core/BFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.6.12;\r\n\r\n// Builds new BPools, logging their addresses and providing `isBPool(address) -> (bool)`\r\n\r\nimport \"./BPool.sol\";\r\nimport \"../IBFactory.sol\";\r\nimport \"../IFCXAccessControl.sol\";\r\n\r\n// Core contract; can't be changed. So disable solhint (reminder for v2)\r\n\r\n/* solhint-disable func-order */\r\n/* solhint-disable event-name-camelcase */\r\n\r\ncontract BFactory is BBronze {\r\n    event LOG_NEW_POOL(address indexed caller, address indexed pool);\r\n\r\n    event LOG_BLABS(address indexed caller, address indexed blabs);\r\n\r\n    mapping(address => bool) private _isBPool;\r\n\r\n    address private _accessAddress;\r\n    address private _logic;\r\n\r\n    constructor(address accessAddress, address logic) public {\r\n        _accessAddress = accessAddress;\r\n        _logic = logic;\r\n        _blabs = msg.sender;\r\n    }\r\n\r\n    function isBPool(address b) external view returns (bool) {\r\n        return _isBPool[b];\r\n    }\r\n\r\n    function newBPool() external returns (BPool) {\r\n        require(\r\n            IFCXAccessControl(_accessAddress).hasRole(keccak256(\"ADMIN_ROLE\"), tx.origin),\r\n            \"AccessControl: sender must be admin to have permission\"\r\n        );\r\n\r\n        BPool bpool = new BPool(_logic);\r\n        _isBPool[address(bpool)] = true;\r\n        emit LOG_NEW_POOL(msg.sender, address(bpool));\r\n        IBPool(address(bpool)).setAccessControlAddress(_accessAddress);\r\n        IBPool(address(bpool)).setController(msg.sender);\r\n        return bpool;\r\n    }\r\n\r\n    address private _blabs;\r\n\r\n    function getBLabs() external view returns (address) {\r\n        return _blabs;\r\n    }\r\n\r\n    function getAccessControlAddress() external view returns (address) {\r\n        return _accessAddress;\r\n    }\r\n\r\n    function setBLabs(address b) external {\r\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\r\n        emit LOG_BLABS(msg.sender, b);\r\n        _blabs = b;\r\n    }\r\n\r\n    function setAccessControlAddress(address accessAddress) external {\r\n        require(\r\n            IFCXAccessControl(_accessAddress).hasRole(keccak256(\"ADMIN_ROLE\"), tx.origin),\r\n            \"AccessControl: sender must be admin to have permission\"\r\n        );\r\n        require(accessAddress != address(0), \"ERR_INVALID_ADDRESS\");\r\n\r\n        require(\r\n            IFCXAccessControl(accessAddress).hasRole(keccak256(\"ADMIN_ROLE\"), tx.origin),\r\n            \"AccessControl: sender must be admin of new access control\"\r\n        );\r\n        _accessAddress = accessAddress;\r\n    }\r\n\r\n    function collect(BPool pool) external {\r\n        require(msg.sender == _blabs, \"ERR_NOT_BLABS\");\r\n        uint256 collected = IERC20(pool).balanceOf(address(this));\r\n        bool xfer = pool.transfer(_blabs, collected);\r\n        require(xfer, \"ERR_ERC20_FAILED\");\r\n    }\r\n}\r\n"
    },
    "contracts/core/BPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"./BToken.sol\";\r\nimport \"./BMath.sol\";\r\nimport \"../IFCXAccessControl.sol\";\r\n\r\n// Core contract; can't be changed. So disable solhint (reminder for v2)\r\n\r\n/* solhint-disable func-order */\r\n/* solhint-disable event-name-camelcase */\r\n\r\ncontract BPool is BBronze, BToken, BMath {\r\n    struct Record {\r\n        bool bound; // is token bound to pool\r\n        uint256 index; // private\r\n        uint256 denorm; // denormalized weight\r\n        uint256 balance;\r\n    }\r\n\r\n    event LOG_SWAP(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        address indexed tokenOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 tokenAmountOut\r\n    );\r\n\r\n    event LOG_JOIN(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\r\n\r\n    event LOG_EXIT(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\r\n\r\n    event LOG_CALL(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\r\n\r\n    modifier _logs_() {\r\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\r\n        _;\r\n    }\r\n\r\n    modifier _lock_() {\r\n        require(!_mutex, \"ERR_REENTRY\");\r\n        _mutex = true;\r\n        _;\r\n        _mutex = false;\r\n    }\r\n\r\n    modifier _viewlock_() {\r\n        require(!_mutex, \"ERR_REENTRY\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhitelist() {\r\n        IFCXAccessControl accessControl = IFCXAccessControl(_accessAddress);\r\n        require(accessControl.whitelisted(tx.origin), \"FCXAccessControl: sender is not in whitelist\");\r\n        _;\r\n    }\r\n\r\n    modifier swapValid() {\r\n        bool check;\r\n        IFCXAccessControl accessControl = IFCXAccessControl(_accessAddress);\r\n        for (uint256 i = 0; i < _roles.length; ++i) {\r\n            if (accessControl.hasRole(_roles[i], tx.origin)) {\r\n                check = true;\r\n                break;\r\n            }\r\n        }\r\n        require(check, \"FCXAccessControl: sender doesn't have same roles as pool\");\r\n        _;\r\n    }\r\n\r\n    bool private _mutex;\r\n\r\n    address private _factory; // BFactory address to push token exitFee to\r\n    address private _controller; // has CONTROL role\r\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\r\n\r\n    // `setSwapFee` and `finalize` require CONTROL\r\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\r\n    uint256 private _swapFee;\r\n    bool private _finalized;\r\n\r\n    address[] private _tokens;\r\n    mapping(address => Record) private _records;\r\n    uint256 private _totalWeight;\r\n\r\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n    uint256 private _protocolFee;\r\n    address private _accessAddress;\r\n    bytes32[] private _roles;\r\n\r\n    constructor(address _logic) public {\r\n        _controller = msg.sender;\r\n        _factory = msg.sender;\r\n        _swapFee = MIN_FEE;\r\n        _publicSwap = false;\r\n        _finalized = false;\r\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\r\n        _setImplementation(_logic);\r\n        _roles = [keccak256(\"ADMIN_ROLE\"), keccak256(\"RESTRICTED_ROLE\"), keccak256(\"UNRESTRICTED_ROLE\")];\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 implementation slot.\r\n     */\r\n    function _setImplementation(address newImplementation) private {\r\n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\r\n\r\n        bytes32 slot = _IMPLEMENTATION_SLOT;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            sstore(slot, newImplementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation address.\r\n     */\r\n    function _implementation() internal view returns (address impl) {\r\n        bytes32 slot = _IMPLEMENTATION_SLOT;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates the current call to `implementation`.\r\n     *\r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _delegate(address implementation) internal {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n     * function in the contract matches the call data.\r\n     */\r\n    fallback() external {\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    function getFCXAdmin() external view returns (address) {\r\n        return IFCXAccessControl(_accessAddress).getRoleMember(keccak256(\"ADMIN_ROLE\"), 0);\r\n    }\r\n\r\n    function finalize() external _logs_ _lock_ {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n        require(_tokens.length >= MIN_BOUND_TOKENS, \"ERR_MIN_TOKENS\");\r\n\r\n        _finalized = true;\r\n        _publicSwap = true;\r\n\r\n        _mintPoolShare(INIT_POOL_SUPPLY);\r\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\r\n    }\r\n\r\n    function bind(\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denorm\r\n    )\r\n        external\r\n        _logs_ // _lock_  Bind does not lock because it jumps to `rebind`, which does\r\n    {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(!_records[token].bound, \"ERR_IS_BOUND\");\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n\r\n        require(_tokens.length < MAX_BOUND_TOKENS, \"ERR_MAX_TOKENS\");\r\n\r\n        _records[token] = Record({\r\n            bound: true,\r\n            index: _tokens.length,\r\n            denorm: 0, // balance and denorm will be validated\r\n            balance: 0 // and set by `rebind`\r\n        });\r\n        _tokens.push(token);\r\n        rebind(token, balance, denorm);\r\n    }\r\n\r\n    function rebind(\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denorm\r\n    ) public _logs_ _lock_ {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n\r\n        require(denorm >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\r\n        require(denorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\r\n        require(balance >= MIN_BALANCE, \"ERR_MIN_BALANCE\");\r\n\r\n        // Adjust the denorm and totalWeight\r\n        uint256 oldWeight = _records[token].denorm;\r\n        if (denorm > oldWeight) {\r\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\r\n            require(_totalWeight <= MAX_TOTAL_WEIGHT, \"ERR_MAX_TOTAL_WEIGHT\");\r\n        } else if (denorm < oldWeight) {\r\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\r\n        }\r\n        _records[token].denorm = denorm;\r\n\r\n        // Adjust the balance record and actual token balance\r\n        uint256 oldBalance = _records[token].balance;\r\n        _records[token].balance = balance;\r\n        if (balance > oldBalance) {\r\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\r\n        } else if (balance < oldBalance) {\r\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\r\n            uint256 tokenBalanceWithdrawn = bsub(oldBalance, balance);\r\n            uint256 tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\r\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\r\n            _pushUnderlying(token, _factory, tokenExitFee);\r\n        }\r\n    }\r\n\r\n    function unbind(address token) external _logs_ _lock_ {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n\r\n        uint256 tokenBalance = _records[token].balance;\r\n        uint256 tokenExitFee = bmul(tokenBalance, EXIT_FEE);\r\n\r\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\r\n\r\n        // Swap the token-to-unbind with the last token,\r\n        // then delete the last token\r\n        uint256 index = _records[token].index;\r\n        uint256 last = _tokens.length - 1;\r\n        _tokens[index] = _tokens[last];\r\n        _records[_tokens[index]].index = index;\r\n        _tokens.pop();\r\n        _records[token] = Record({bound: false, index: 0, denorm: 0, balance: 0});\r\n\r\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\r\n        _pushUnderlying(token, _factory, tokenExitFee);\r\n    }\r\n\r\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external onlyWhitelist _logs_ _lock_ {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n\r\n        uint256 poolTotal = totalSupply();\r\n        uint256 ratio = bdiv(poolAmountOut, poolTotal);\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint256 bal = _records[t].balance;\r\n            uint256 tokenAmountIn = bmul(ratio, bal);\r\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\r\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\r\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\r\n        }\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n    }\r\n\r\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external onlyWhitelist _logs_ _lock_ {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n\r\n        uint256 poolTotal = totalSupply();\r\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\r\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\r\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _pushPoolShare(_factory, exitFee);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint256 bal = _records[t].balance;\r\n            uint256 tokenAmountOut = bmul(ratio, bal);\r\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\r\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\r\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\r\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\r\n        }\r\n    }\r\n\r\n    function swapExactAmountIn(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice\r\n    ) external swapValid _logs_ _lock_ returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\r\n\r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\r\n\r\n        uint256 spotPriceBefore = calcSpotPrice(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            _swapFee\r\n        );\r\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\r\n\r\n        tokenAmountOut = calcOutGivenIn(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            tokenAmountIn,\r\n            _swapFee\r\n        );\r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        spotPriceAfter = calcSpotPrice(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            _swapFee\r\n        );\r\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\r\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\r\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\r\n\r\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        _pushUnderlying(tokenIn, this.getFCXAdmin(), bmul(_protocolFee, tokenAmountIn));\r\n        inRecord.balance = bsub(inRecord.balance, bmul(_protocolFee, tokenAmountIn));\r\n\r\n        return (tokenAmountOut, spotPriceAfter);\r\n    }\r\n\r\n    function swapExactAmountOut(\r\n        address tokenIn,\r\n        uint256 maxAmountIn,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPrice\r\n    ) external swapValid _logs_ _lock_ returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\r\n\r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\r\n\r\n        uint256 spotPriceBefore = calcSpotPrice(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            _swapFee\r\n        );\r\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\r\n\r\n        tokenAmountIn = calcInGivenOut(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            tokenAmountOut,\r\n            _swapFee\r\n        );\r\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        spotPriceAfter = calcSpotPrice(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            _swapFee\r\n        );\r\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\r\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\r\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\r\n\r\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        _pushUnderlying(tokenIn, this.getFCXAdmin(), bmul(_protocolFee, tokenAmountIn));\r\n        inRecord.balance = bsub(inRecord.balance, bmul(_protocolFee, tokenAmountIn));\r\n\r\n        return (tokenAmountIn, spotPriceAfter);\r\n    }\r\n\r\n    function joinswapExternAmountIn(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        uint256 minPoolAmountOut\r\n    ) external onlyWhitelist _logs_ _lock_ returns (uint256 poolAmountOut) {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\r\n\r\n        Record storage inRecord = _records[tokenIn];\r\n\r\n        poolAmountOut = calcPoolOutGivenSingleIn(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            _totalSupply,\r\n            _totalWeight,\r\n            tokenAmountIn,\r\n            _swapFee\r\n        );\r\n\r\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n\r\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        return poolAmountOut;\r\n    }\r\n\r\n    function joinswapPoolAmountOut(\r\n        address tokenIn,\r\n        uint256 poolAmountOut,\r\n        uint256 maxAmountIn\r\n    ) external onlyWhitelist _logs_ _lock_ returns (uint256 tokenAmountIn) {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n\r\n        Record storage inRecord = _records[tokenIn];\r\n\r\n        tokenAmountIn = calcSingleInGivenPoolOut(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            _totalSupply,\r\n            _totalWeight,\r\n            poolAmountOut,\r\n            _swapFee\r\n        );\r\n\r\n        require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n\r\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    function exitswapPoolAmountIn(\r\n        address tokenOut,\r\n        uint256 poolAmountIn,\r\n        uint256 minAmountOut\r\n    ) external onlyWhitelist _logs_ _lock_ returns (uint256 tokenAmountOut) {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n\r\n        Record storage outRecord = _records[tokenOut];\r\n\r\n        tokenAmountOut = calcSingleOutGivenPoolIn(\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            _totalSupply,\r\n            _totalWeight,\r\n            poolAmountIn,\r\n            _swapFee\r\n        );\r\n\r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n\r\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\r\n\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\r\n\r\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\r\n        _pushPoolShare(_factory, exitFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    function exitswapExternAmountOut(\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPoolAmountIn\r\n    ) external onlyWhitelist _logs_ _lock_ returns (uint256 poolAmountIn) {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \"ERR_MAX_OUT_RATIO\");\r\n\r\n        Record storage outRecord = _records[tokenOut];\r\n\r\n        poolAmountIn = calcPoolInGivenSingleOut(\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            _totalSupply,\r\n            _totalWeight,\r\n            tokenAmountOut,\r\n            _swapFee\r\n        );\r\n\r\n        require(poolAmountIn != 0, \"ERR_MATH_APPROX\");\r\n        require(poolAmountIn <= maxPoolAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        uint256 exitFee = bmul(poolAmountIn, EXIT_FEE);\r\n\r\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\r\n        _pushPoolShare(_factory, exitFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return poolAmountIn;\r\n    }\r\n\r\n    // ==\r\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\r\n    // You must `_lock_` or otherwise ensure reentry-safety\r\n\r\n    function _pullUnderlying(\r\n        address erc20,\r\n        address from,\r\n        uint256 amount\r\n    ) internal {\r\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n    }\r\n\r\n    function _pushUnderlying(\r\n        address erc20,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool xfer = IERC20(erc20).transfer(to, amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n    }\r\n\r\n    function _pullPoolShare(address from, uint256 amount) internal {\r\n        _pull(from, amount);\r\n    }\r\n\r\n    function _pushPoolShare(address to, uint256 amount) internal {\r\n        _push(to, amount);\r\n    }\r\n\r\n    function _mintPoolShare(uint256 amount) internal {\r\n        _mint(amount);\r\n    }\r\n\r\n    function _burnPoolShare(uint256 amount) internal {\r\n        _burn(amount);\r\n    }\r\n}\r\n"
    },
    "contracts/core/BToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.6.12;\r\n\r\nimport \"./BNum.sol\";\r\n\r\n// Highly opinionated token implementation\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed src, address indexed dst, uint256 amt);\r\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address whom) external view returns (uint256);\r\n\r\n    function allowance(address src, address dst) external view returns (uint256);\r\n\r\n    function approve(address dst, uint256 amt) external returns (bool);\r\n\r\n    function transfer(address dst, uint256 amt) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 amt\r\n    ) external returns (bool);\r\n}\r\n\r\n// Core contract; can't be changed. So disable solhint (reminder for v2)\r\n\r\n/* solhint-disable func-order */\r\n\r\ncontract BTokenBase is BNum {\r\n    mapping(address => uint256) internal _balance;\r\n    mapping(address => mapping(address => uint256)) internal _allowance;\r\n    uint256 internal _totalSupply;\r\n\r\n    event Approval(address indexed src, address indexed dst, uint256 amt);\r\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\r\n\r\n    function _mint(uint256 amt) internal {\r\n        _balance[address(this)] = badd(_balance[address(this)], amt);\r\n        _totalSupply = badd(_totalSupply, amt);\r\n        emit Transfer(address(0), address(this), amt);\r\n    }\r\n\r\n    function _burn(uint256 amt) internal {\r\n        require(_balance[address(this)] >= amt, \"ERR_INSUFFICIENT_BAL\");\r\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\r\n        _totalSupply = bsub(_totalSupply, amt);\r\n        emit Transfer(address(this), address(0), amt);\r\n    }\r\n\r\n    function _move(\r\n        address src,\r\n        address dst,\r\n        uint256 amt\r\n    ) internal {\r\n        require(_balance[src] >= amt, \"ERR_INSUFFICIENT_BAL\");\r\n        _balance[src] = bsub(_balance[src], amt);\r\n        _balance[dst] = badd(_balance[dst], amt);\r\n        emit Transfer(src, dst, amt);\r\n    }\r\n\r\n    function _push(address to, uint256 amt) internal {\r\n        _move(address(this), to, amt);\r\n    }\r\n\r\n    function _pull(address from, uint256 amt) internal {\r\n        _move(from, address(this), amt);\r\n    }\r\n}\r\n\r\ncontract BToken is BTokenBase, IERC20 {\r\n    string private _name = \"FCX Pool Token\";\r\n    string private _symbol = \"FPT\";\r\n    uint8 private _decimals = 18;\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function allowance(address src, address dst) external view override returns (uint256) {\r\n        return _allowance[src][dst];\r\n    }\r\n\r\n    function balanceOf(address whom) external view override returns (uint256) {\r\n        return _balance[whom];\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function approve(address dst, uint256 amt) external override returns (bool) {\r\n        _allowance[msg.sender][dst] = amt;\r\n        emit Approval(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address dst, uint256 amt) external returns (bool) {\r\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address dst, uint256 amt) external returns (bool) {\r\n        uint256 oldValue = _allowance[msg.sender][dst];\r\n        if (amt > oldValue) {\r\n            _allowance[msg.sender][dst] = 0;\r\n        } else {\r\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\r\n        }\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint256 amt) external override returns (bool) {\r\n        _move(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 amt\r\n    ) external override returns (bool) {\r\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"ERR_BTOKEN_BAD_CALLER\");\r\n        _move(src, dst, amt);\r\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\r\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\r\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/core/BMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.6.12;\r\n\r\nimport \"./BNum.sol\";\r\n\r\ncontract BMath is BBronze, BConst, BNum {\r\n    /**********************************************************************************************\r\n    // calcSpotPrice                                                                             //\r\n    // sP = spotPrice                                                                            //\r\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\r\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\r\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcSpotPrice(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 spotPrice) {\r\n        uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\r\n        uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\r\n        uint256 ratio = bdiv(numer, denom);\r\n        uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\r\n        return (spotPrice = bmul(ratio, scale));\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcOutGivenIn                                                                            //\r\n    // aO = tokenAmountOut                                                                       //\r\n    // bO = tokenBalanceOut                                                                      //\r\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\r\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\r\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcOutGivenIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountOut) {\r\n        uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\r\n        uint256 adjustedIn = bsub(BONE, swapFee);\r\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\r\n        uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\r\n        uint256 foo = bpow(y, weightRatio);\r\n        uint256 bar = bsub(BONE, foo);\r\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcInGivenOut                                                                            //\r\n    // aI = tokenAmountIn                                                                        //\r\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\r\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\r\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\r\n    // wI = tokenWeightIn           --------------------------------------------                 //\r\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcInGivenOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountIn) {\r\n        uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\r\n        uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\r\n        uint256 y = bdiv(tokenBalanceOut, diff);\r\n        uint256 foo = bpow(y, weightRatio);\r\n        foo = bsub(foo, BONE);\r\n        tokenAmountIn = bsub(BONE, swapFee);\r\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcPoolOutGivenSingleIn                                                                  //\r\n    // pAo = poolAmountOut         /                                              \\              //\r\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\r\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\r\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\r\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\r\n    // pS = poolSupply            \\\\                    tBi               /        /             //\r\n    // sF = swapFee                \\                                              /              //\r\n    **********************************************************************************************/\r\n    function calcPoolOutGivenSingleIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 tokenAmountIn,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 poolAmountOut) {\r\n        // Charge the trading fee for the proportion of tokenAi\r\n        ///  which is implicitly traded to the other pool tokens.\r\n        // That proportion is (1- weightTokenIn)\r\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\r\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\r\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\r\n        uint256 tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\r\n\r\n        uint256 newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\r\n        uint256 tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\r\n\r\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\r\n        uint256 poolRatio = bpow(tokenInRatio, normalizedWeight);\r\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\r\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\r\n        return poolAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcSingleInGivenPoolOut                                                                  //\r\n    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\r\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\r\n    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\r\n    // bI = balanceIn          tAi =  --------------------------------------------               //\r\n    // wI = weightIn                              /      wI  \\                                   //\r\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\r\n    // sF = swapFee                               \\      tW  /                                   //\r\n    **********************************************************************************************/\r\n    function calcSingleInGivenPoolOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 poolAmountOut,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountIn) {\r\n        uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\r\n        uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\r\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\r\n\r\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\r\n        uint256 boo = bdiv(BONE, normalizedWeight);\r\n        uint256 tokenInRatio = bpow(poolRatio, boo);\r\n        uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\r\n        uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\r\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\r\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\r\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\r\n        uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\r\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcSingleOutGivenPoolIn                                                                  //\r\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\r\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\r\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\r\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\r\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\r\n    // tW = totalWeight                    /     /      wO \\       \\                             //\r\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\r\n    // eF = exitFee                        \\     \\      tW /       /                             //\r\n    **********************************************************************************************/\r\n    function calcSingleOutGivenPoolIn(\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 poolAmountIn,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 tokenAmountOut) {\r\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\r\n        // charge exit fee on the pool token side\r\n        // pAiAfterExitFee = pAi*(1-exitFee)\r\n        uint256 poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\r\n        uint256 newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\r\n        uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\r\n\r\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\r\n        uint256 tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\r\n        uint256 newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\r\n\r\n        uint256 tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\r\n\r\n        // charge swap fee on the output token side\r\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\r\n        uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\r\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcPoolInGivenSingleOut                                                                  //\r\n    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\r\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\r\n    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\r\n    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\r\n    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\r\n    // tW = totalWeight           -------------------------------------------------------------  //\r\n    // sF = swapFee                                        ( 1 - eF )                            //\r\n    // eF = exitFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcPoolInGivenSingleOut(\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 tokenAmountOut,\r\n        uint256 swapFee\r\n    ) public pure returns (uint256 poolAmountIn) {\r\n        // charge swap fee on the output token side\r\n        uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\r\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\r\n        uint256 zoo = bsub(BONE, normalizedWeight);\r\n        uint256 zar = bmul(zoo, swapFee);\r\n        uint256 tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\r\n\r\n        uint256 newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\r\n        uint256 tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\r\n\r\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\r\n        uint256 poolRatio = bpow(tokenOutRatio, normalizedWeight);\r\n        uint256 newPoolSupply = bmul(poolRatio, poolSupply);\r\n        uint256 poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\r\n\r\n        // charge exit fee on the pool token side\r\n        // pAi = pAiAfterExitFee/(1-exitFee)\r\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\r\n        return poolAmountIn;\r\n    }\r\n}\r\n"
    },
    "contracts/core/BNum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.6.12;\r\n\r\nimport \"./BConst.sol\";\r\n\r\n// Core contract; can't be changed. So disable solhint (reminder for v2)\r\n\r\n/* solhint-disable private-vars-leading-underscore */\r\n\r\ncontract BNum is BConst {\r\n    function btoi(uint256 a) internal pure returns (uint256) {\r\n        return a / BONE;\r\n    }\r\n\r\n    function bfloor(uint256 a) internal pure returns (uint256) {\r\n        return btoi(a) * BONE;\r\n    }\r\n\r\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        (uint256 c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c1 = c0 + (BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c2 = c1 / BONE;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint256 c0 = a * BONE;\r\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint256 c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint256 c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    // DSMath.wpow\r\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\r\n        uint256 z = n % 2 != 0 ? a : BONE;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\r\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\r\n    // of approximation of b^0.w\r\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\r\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\r\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\r\n\r\n        uint256 whole = bfloor(exp);\r\n        uint256 remain = bsub(exp, whole);\r\n\r\n        uint256 wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(\r\n        uint256 base,\r\n        uint256 exp,\r\n        uint256 precision\r\n    ) internal pure returns (uint256) {\r\n        // term 0:\r\n        uint256 a = exp;\r\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\r\n        uint256 term = BONE;\r\n        uint256 sum = term;\r\n        bool negative = false;\r\n\r\n        // term(k) = numer / denom\r\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\r\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\r\n        // continue until term is less than precision\r\n        for (uint256 i = 1; term >= precision; i++) {\r\n            uint256 bigK = i * BONE;\r\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n"
    },
    "contracts/core/BConst.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.6.12;\r\n\r\nimport \"./BColor.sol\";\r\n\r\ncontract BConst is BBronze {\r\n    uint256 public constant BONE = 10**18;\r\n\r\n    uint256 public constant MIN_BOUND_TOKENS = 2;\r\n    uint256 public constant MAX_BOUND_TOKENS = 8;\r\n\r\n    uint256 public constant MIN_FEE = BONE / 10**6;\r\n    // uint256 public constant MAX_FEE = BONE / 10;\r\n    // FCX: max fee is 100%\r\n    uint256 public constant MAX_FEE = BONE;\r\n    uint256 public constant EXIT_FEE = 0;\r\n\r\n    uint256 public constant MIN_WEIGHT = BONE;\r\n    uint256 public constant MAX_WEIGHT = BONE * 50;\r\n    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\r\n    uint256 public constant MIN_BALANCE = BONE / 10**12;\r\n\r\n    uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\r\n\r\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\r\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\r\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\r\n\r\n    uint256 public constant MAX_IN_RATIO = BONE / 2;\r\n    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\r\n}\r\n"
    },
    "contracts/core/BColor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.6.12;\r\n\r\nabstract contract BColor {\r\n    function getColor() external view virtual returns (bytes32);\r\n}\r\n\r\ncontract BBronze is BColor {\r\n    function getColor() external view override returns (bytes32) {\r\n        return bytes32(\"BRONZE\");\r\n    }\r\n}\r\n"
    },
    "contracts/CRPFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n// Needed to handle structures externally\r\npragma experimental ABIEncoderV2;\r\n\r\n// Imports\r\n\r\nimport \"./ConfigurableRightsPool.sol\";\r\nimport \"./IFCXAccessControl.sol\";\r\n\r\n// Contracts\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Configurable Rights Pool Factory - create parameterized smart pools\r\n * @dev Rights are held in a corresponding struct in ConfigurableRightsPool\r\n *      Index values are as follows:\r\n *      0: canPauseSwapping - can setPublicSwap back to false after turning it on\r\n *                            by default, it is off on initialization and can only be turned on\r\n *      1: canChangeSwapFee - can setSwapFee after initialization (by default, it is fixed at create time)\r\n *      2: canChangeWeights - can bind new token weights (allowed by default in base pool)\r\n *      3: canAddRemoveTokens - can bind/unbind tokens (allowed by default in base pool)\r\n *      4: canWhitelistLPs - if set, only whitelisted addresses can join pools\r\n *                           (enables private pools with more than one LP)\r\n *      5: canChangeCap - can change the BSP cap (max # of pool tokens)\r\n */\r\n\r\ncontract CRPFactory {\r\n    // State variables\r\n    // Keep a list of all Configurable Rights Pools\r\n    mapping(address => bool) private _isCrp;\r\n\r\n    address private _accessAddress;\r\n    address private _logic;\r\n\r\n    constructor(address accessAddress, address logic) public {\r\n        _accessAddress = accessAddress;\r\n        _logic = logic;\r\n    }\r\n\r\n    // Event declarations\r\n\r\n    // Log the address of each new smart pool, and its creator\r\n    event LogNewCrp(address indexed caller, address indexed pool);\r\n\r\n    // Function declarations\r\n\r\n    /**\r\n     * @notice Create a new CRP\r\n     * @dev emits a LogNewCRP event\r\n     * @param factoryAddress - the BFactory instance used to create the underlying pool\r\n     * @param poolParams - struct containing the names, tokens, weights, balances, and swap fee\r\n     * @param rights - struct of permissions, configuring this CRP instance (see above for definitions)\r\n\r\n     */\r\n    function newCrp(\r\n        address factoryAddress,\r\n        ConfigurableRightsPool.PoolParams calldata poolParams,\r\n        RightsManager.Rights calldata rights\r\n    ) external returns (ConfigurableRightsPool) {\r\n        require(\r\n            IFCXAccessControl(_accessAddress).hasRole(keccak256(\"ADMIN_ROLE\"), tx.origin),\r\n            \"AccessControl: sender must be admin to have permission\"\r\n        );\r\n        require(poolParams.constituentTokens.length >= BalancerConstants.MIN_ASSET_LIMIT, \"ERR_TOO_FEW_TOKENS\");\r\n\r\n        // Arrays must be parallel\r\n        require(poolParams.tokenBalances.length == poolParams.constituentTokens.length, \"ERR_START_BALANCES_MISMATCH\");\r\n        require(poolParams.tokenWeights.length == poolParams.constituentTokens.length, \"ERR_START_WEIGHTS_MISMATCH\");\r\n\r\n        ConfigurableRightsPool crp = new ConfigurableRightsPool(factoryAddress, _logic, poolParams, rights);\r\n\r\n        emit LogNewCrp(msg.sender, address(crp));\r\n\r\n        _isCrp[address(crp)] = true;\r\n        // The caller is the controller of the CRP\r\n        // The CRP will be the controller of the underlying Core BPool\r\n        crp.setController(msg.sender);\r\n\r\n        return crp;\r\n    }\r\n\r\n    /**\r\n     * @notice Check to see if a given address is a CRP\r\n     * @param addr - address to check\r\n     * @return boolean indicating whether it is a CRP\r\n     */\r\n    function isCrp(address addr) external view returns (bool) {\r\n        return _isCrp[addr];\r\n    }\r\n\r\n    function getAccessControlAddress() external view returns (address) {\r\n        return _accessAddress;\r\n    }\r\n\r\n    function setAccessControlAddress(address accessAddress) external {\r\n        require(\r\n            IFCXAccessControl(_accessAddress).hasRole(keccak256(\"ADMIN_ROLE\"), tx.origin),\r\n            \"AccessControl: sender must be admin to have permission\"\r\n        );\r\n        require(accessAddress != address(0), \"ERR_INVALID_ADDRESS\");\r\n\r\n        require(\r\n            IFCXAccessControl(accessAddress).hasRole(keccak256(\"ADMIN_ROLE\"), tx.origin),\r\n            \"AccessControl: sender must be admin of new access control\"\r\n        );\r\n        _accessAddress = accessAddress;\r\n    }\r\n}\r\n"
    },
    "contracts/test/TMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.6;\r\n\r\nimport \"../core/BMath.sol\";\r\nimport \"../core/BNum.sol\";\r\n\r\n// Contract to wrap internal functions for testing\r\n\r\ncontract TMath is BMath {\r\n    function calc_btoi(uint256 a) external pure returns (uint256) {\r\n        return btoi(a);\r\n    }\r\n\r\n    function calc_bfloor(uint256 a) external pure returns (uint256) {\r\n        return bfloor(a);\r\n    }\r\n\r\n    function calc_badd(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return badd(a, b);\r\n    }\r\n\r\n    function calc_bsub(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return bsub(a, b);\r\n    }\r\n\r\n    function calc_bsubSign(uint256 a, uint256 b) external pure returns (uint256, bool) {\r\n        return bsubSign(a, b);\r\n    }\r\n\r\n    function calc_bmul(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return bmul(a, b);\r\n    }\r\n\r\n    function calc_bdiv(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return bdiv(a, b);\r\n    }\r\n\r\n    function calc_bpowi(uint256 a, uint256 n) external pure returns (uint256) {\r\n        return bpowi(a, n);\r\n    }\r\n\r\n    function calc_bpow(uint256 base, uint256 exp) external pure returns (uint256) {\r\n        return bpow(base, exp);\r\n    }\r\n\r\n    function calc_bpowApprox(\r\n        uint256 base,\r\n        uint256 exp,\r\n        uint256 precision\r\n    ) external pure returns (uint256) {\r\n        return bpowApprox(base, exp, precision);\r\n    }\r\n}\r\n"
    },
    "contracts/core/BPoolExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.6.12;\r\n\r\nimport \"./BToken.sol\";\r\nimport \"./BMath.sol\";\r\n\r\ncontract BPoolExtension is BBronze, BToken, BMath {\r\n    struct Record {\r\n        bool bound; // is token bound to pool\r\n        uint256 index; // private\r\n        uint256 denorm; // denormalized weight\r\n        uint256 balance;\r\n    }\r\n\r\n    event LOG_CALL(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\r\n\r\n    modifier _logs_() {\r\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\r\n        _;\r\n    }\r\n\r\n    modifier _lock_() {\r\n        require(!_mutex, \"ERR_REENTRY\");\r\n        _mutex = true;\r\n        _;\r\n        _mutex = false;\r\n    }\r\n\r\n    modifier _viewlock_() {\r\n        require(!_mutex, \"ERR_REENTRY\");\r\n        _;\r\n    }\r\n\r\n    bool private _mutex;\r\n\r\n    address private _factory; // BFactory address to push token exitFee to\r\n    address private _controller; // has CONTROL role\r\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\r\n\r\n    // `setSwapFee` and `finalize` require CONTROL\r\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\r\n    uint256 private _swapFee;\r\n    bool private _finalized;\r\n\r\n    address[] private _tokens;\r\n    mapping(address => Record) private _records;\r\n    uint256 private _totalWeight;\r\n\r\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n    uint256 private _protocolFee;\r\n    address private _accessAddress;\r\n    bytes32[] private _roles;\r\n\r\n    constructor() public {}\r\n\r\n    function isPublicSwap() external view returns (bool) {\r\n        return _publicSwap;\r\n    }\r\n\r\n    function isFinalized() external view returns (bool) {\r\n        return _finalized;\r\n    }\r\n\r\n    function isBound(address t) external view returns (bool) {\r\n        return _records[t].bound;\r\n    }\r\n\r\n    function getNumTokens() external view returns (uint256) {\r\n        return _tokens.length;\r\n    }\r\n\r\n    function getCurrentTokens() external view _viewlock_ returns (address[] memory tokens) {\r\n        return _tokens;\r\n    }\r\n\r\n    function getFinalTokens() external view _viewlock_ returns (address[] memory tokens) {\r\n        require(_finalized, \"ERR_NOT_FINALIZED\");\r\n        return _tokens;\r\n    }\r\n\r\n    function getDenormalizedWeight(address token) external view _viewlock_ returns (uint256) {\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        return _records[token].denorm;\r\n    }\r\n\r\n    function getTotalDenormalizedWeight() external view _viewlock_ returns (uint256) {\r\n        return _totalWeight;\r\n    }\r\n\r\n    function getNormalizedWeight(address token) external view _viewlock_ returns (uint256) {\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        uint256 denorm = _records[token].denorm;\r\n        return bdiv(denorm, _totalWeight);\r\n    }\r\n\r\n    function getBalance(address token) external view _viewlock_ returns (uint256) {\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        return _records[token].balance;\r\n    }\r\n\r\n    function getSwapFee() external view _viewlock_ returns (uint256) {\r\n        return _swapFee;\r\n    }\r\n\r\n    function getController() external view _viewlock_ returns (address) {\r\n        return _controller;\r\n    }\r\n\r\n    function getProtocolFee() external view _viewlock_ returns (uint256) {\r\n        return _protocolFee;\r\n    }\r\n\r\n    function getAccessControlAddress() external view _viewlock_ returns (address) {\r\n        return _accessAddress;\r\n    }\r\n\r\n    function getRoles() external view _viewlock_ returns (bytes32[] memory roles) {\r\n        return _roles;\r\n    }\r\n\r\n    function setAccessControlAddress(address accessAddress) external _logs_ _lock_ {\r\n        // require(!_finalized, \"ERR_IS_FINALIZED\");\r\n\r\n        require(accessAddress != address(0), \"ERR_INVALID_ADDRESS\");\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        _accessAddress = accessAddress;\r\n    }\r\n\r\n    function setController(address manager) external _logs_ _lock_ {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        _controller = manager;\r\n    }\r\n\r\n    function setProtocolFee(uint256 protoFee) external _logs_ _lock_ {\r\n        // require(!_finalized, \"ERR_IS_FINALIZED\");\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        // require(protoFee >= MIN_FEE, \"ERR_MIN_FEE\");\r\n        require(protoFee <= MAX_FEE, \"ERR_MAX_FEE\");\r\n        require(protoFee <= _swapFee, \"ERR_INVALID_FEE\");\r\n        _protocolFee = protoFee;\r\n    }\r\n\r\n    function setRoles(bytes32[] memory roles) external _logs_ _lock_ {\r\n        // require(!_finalized, \"ERR_IS_FINALIZED\");\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        _roles = roles;\r\n    }\r\n\r\n    function setSwapFee(uint256 swapFee) external _logs_ _lock_ {\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(swapFee >= MIN_FEE, \"ERR_MIN_FEE\");\r\n        require(swapFee <= MAX_FEE, \"ERR_MAX_FEE\");\r\n        _swapFee = swapFee;\r\n    }\r\n\r\n    function setPublicSwap(bool public_) external _logs_ _lock_ {\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        _publicSwap = public_;\r\n    }\r\n\r\n    // Absorb any tokens that have been sent to this contract into the pool\r\n    function gulp(address token) external _logs_ _lock_ {\r\n        require(_records[token].bound, \"ERR_NOT_BOUND\");\r\n        _records[token].balance = IERC20(token).balanceOf(address(this));\r\n    }\r\n\r\n    function getSpotPrice(address tokenIn, address tokenOut) external view _viewlock_ returns (uint256 spotPrice) {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        Record storage inRecord = _records[tokenIn];\r\n        Record storage outRecord = _records[tokenOut];\r\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\r\n    }\r\n\r\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\r\n        external\r\n        view\r\n        _viewlock_\r\n        returns (uint256 spotPrice)\r\n    {\r\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\r\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\r\n        Record storage inRecord = _records[tokenIn];\r\n        Record storage outRecord = _records[tokenOut];\r\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\r\n    }\r\n\r\n    function finalize() external _logs_ _lock_ {\r\n        require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");\r\n        require(!_finalized, \"ERR_IS_FINALIZED\");\r\n        require(_tokens.length >= MIN_BOUND_TOKENS, \"ERR_MIN_TOKENS\");\r\n\r\n        _finalized = true;\r\n        _publicSwap = true;\r\n\r\n        _mintPoolShare(INIT_POOL_SUPPLY);\r\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\r\n    }\r\n\r\n    // ==\r\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\r\n    // You must `_lock_` or otherwise ensure reentry-safety\r\n\r\n    function _pushPoolShare(address to, uint256 amount) internal {\r\n        _push(to, amount);\r\n    }\r\n\r\n    function _mintPoolShare(uint256 amount) internal {\r\n        _mint(amount);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/test/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.6.6;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n// mock class using ERC20\r\ncontract ERC20Mock is ERC20 {\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint8 decimals\r\n    ) public ERC20(name, symbol) {}\r\n\r\n    function mint(address account, uint256 amount) public {\r\n        _mint(account, amount);\r\n    }\r\n\r\n    function burn(address account, uint256 amount) public {\r\n        _burn(account, amount);\r\n    }\r\n\r\n    function transferInternal(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) public {\r\n        _transfer(from, to, value);\r\n    }\r\n\r\n    function approveInternal(\r\n        address owner,\r\n        address spender,\r\n        uint256 value\r\n    ) public {\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n"
    },
    "contracts/FCXAccessControl.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\n// Needed to handle structures externally\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\n\r\ncontract FCXAccessControl is AccessControl {\r\n    bytes32 public constant SUPER_ADMIN_ROLE = keccak256(\"SUPER_ADMIN_ROLE\");\r\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\r\n    bytes32 public constant RESTRICTED_ROLE = keccak256(\"RESTRICTED_ROLE\");\r\n    bytes32 public constant UNRESTRICTED_ROLE = keccak256(\"UNRESTRICTED_ROLE\");\r\n\r\n    struct GrantParams {\r\n        address account;\r\n        bytes32 role;\r\n    }\r\n\r\n    /**\r\n     * @dev FCX user manager.\r\n     */\r\n    constructor(\r\n        address adminAddress,\r\n        address[] memory restrictedAddresses,\r\n        address[] memory unrestrictedAddresses\r\n    ) public {\r\n        _setRoleAdmin(SUPER_ADMIN_ROLE, SUPER_ADMIN_ROLE);\r\n        _setRoleAdmin(ADMIN_ROLE, SUPER_ADMIN_ROLE);\r\n        _setRoleAdmin(RESTRICTED_ROLE, ADMIN_ROLE);\r\n        _setRoleAdmin(UNRESTRICTED_ROLE, ADMIN_ROLE);\r\n\r\n        // deployer + self administration\r\n        _setupRole(SUPER_ADMIN_ROLE, adminAddress);\r\n        _setupRole(ADMIN_ROLE, adminAddress);\r\n\r\n        // register proposers\r\n        for (uint256 i = 0; i < restrictedAddresses.length; ++i) {\r\n            _setupRole(RESTRICTED_ROLE, restrictedAddresses[i]);\r\n        }\r\n\r\n        // register executors\r\n        for (uint256 i = 0; i < unrestrictedAddresses.length; ++i) {\r\n            _setupRole(UNRESTRICTED_ROLE, unrestrictedAddresses[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `roles` to `accounts`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRoles(GrantParams[] calldata params) public virtual {\r\n        for (uint256 i = 0; i < params.length; i++) {\r\n            GrantParams calldata entity = params[i];\r\n            if (entity.role == ADMIN_ROLE && !hasRole(UNRESTRICTED_ROLE, entity.account)) {\r\n                grantRole(UNRESTRICTED_ROLE, entity.account);\r\n            }\r\n            if (entity.role == RESTRICTED_ROLE && hasRole(UNRESTRICTED_ROLE, entity.account)) {\r\n                revokeRole(UNRESTRICTED_ROLE, entity.account);\r\n            }\r\n            if (entity.role == UNRESTRICTED_ROLE && hasRole(RESTRICTED_ROLE, entity.account)) {\r\n                revokeRole(RESTRICTED_ROLE, entity.account);\r\n            }\r\n\r\n            grantRole(entity.role, entity.account);\r\n        }\r\n    }\r\n\r\n    function blacklist(address[] calldata accounts) public virtual {\r\n        for (uint256 i = 0; i < accounts.length; i++) {\r\n            address account = accounts[i];\r\n            if (hasRole(UNRESTRICTED_ROLE, account)) {\r\n                revokeRole(UNRESTRICTED_ROLE, account);\r\n            }\r\n            if (hasRole(RESTRICTED_ROLE, account)) {\r\n                revokeRole(RESTRICTED_ROLE, account);\r\n            }\r\n            if (hasRole(ADMIN_ROLE, account)) {\r\n                revokeRole(ADMIN_ROLE, account);\r\n            }\r\n            if (hasRole(SUPER_ADMIN_ROLE, account)) {\r\n                revokeRole(SUPER_ADMIN_ROLE, account);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev get all roles of account\r\n     */\r\n    function getRoles(address account) public view returns (bytes32[] memory) {\r\n        bytes32[4] memory roles = [ADMIN_ROLE, RESTRICTED_ROLE, UNRESTRICTED_ROLE, SUPER_ADMIN_ROLE];\r\n        bytes32[] memory result = new bytes32[](4);\r\n\r\n        for (uint256 i = 0; i < roles.length; i++) {\r\n            if (hasRole(roles[i], account)) {\r\n                result[i] = roles[i];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev check account in whitelist\r\n     */\r\n    function whitelisted(address account) public view returns (bool) {\r\n        bytes32[4] memory roles = [ADMIN_ROLE, RESTRICTED_ROLE, UNRESTRICTED_ROLE, SUPER_ADMIN_ROLE];\r\n        for (uint256 i = 0; i < roles.length; i++) {\r\n            if (hasRole(roles[i], account)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true,
        "deduplicate": true,
        "cse": true,
        "constantOptimizer": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}